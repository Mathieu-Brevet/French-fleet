---
title: "Def_flottille_improved"
author: "Mathieu Brevet"
format: html
---


```{r loading used packages and functions}

# Coded on R version 4.3.1 ("Beagle Scouts"), Rstudio version "Mountain Hydrangea" (2023.06.0)



library(stringr) # string processing package

library(vegan) #computation of diversity indexes 

library(kableExtra) # conversion/modification of table in different format (e.g. from R format to Latex format)

library(data.table) #more efficient management of large data sets

library(microbenchmark) # assess efficiency of codes (in system time)

library(RVAideMemoire) #used for post-hoc tests in exploratory analyses




library(arules)
library(arulesViz) # packages on association rule mining (“market-basket” model of data), "A-priori" algorithm allowing to identify most associated categories





  pop.sd <- function(x) sqrt(sum((x - mean(x))^2)/(length(x)))
  
  #population sd (biased estimate: divided by n not by n-1, necessary here because we want vessels with only one values to be categorized as vessels with null variance and not as vessels with missing variance)
  
  
  
  
  
  
  
  
  
  

  
  #### functions describing diversity:
  
  
    # number of categories:
  
  
  number_cat <- function(data, ID, value, averaged=FALSE, scale=NULL, SD=FALSE) { # data: data.table format, analysed dataset / ID: character, name of the variable containing individual trip or vessel IDs - WARNING: when using the function with averaging at trip level the ID MUST take into account overlapping fishing trip (attributing it to a unique vessel => "vessel_ID" in our case) / value: character, name of the categorical variable for which we want to obtain the number of categories / averaged: boolean, is the number of categories averaged between different levels ? / scale: character, if averaged==T, name of the variable indicating the different levels to consider, e.g. trip or sequence IDs / SD: boolean, if TRUE return the Standard deviation between the different level 
    .ID=as.name(ID);
    .value=as.name(value); #converting strings input in names
    if (!averaged) {
      eval( #evaluating the string command below
        substitute( #substituting strings by names
          data[!is.na(value),   #removing NAs to avoid taking them into account for the count number
                length( 
                  unique(value)),  #number of occurence per ID
                     by=ID], list(ID=.ID, value=.value)))
    }
    else {
      .scale=as.name(scale);
      eval(
        substitute(
          SACROIS[!is.na(value),
                    length( 
                      unique(value)), #number of occurence per scale unit
                        by=.(ID,scale)] [, ifelse(SD, pop.sd(V1), mean(V1)), #averaged/SD over ID
                                          by=ID ], list(ID=.ID, value=.value, scale=.scale)))
    }
  }
  
  
  

  
  
  
 
    
    # diversity indexes:
  
  
  div_index <- function(data, ID, value, method="simpson", abundance=NULL, constant=FALSE, event, averaged=FALSE, scale=NULL, SD=FALSE) { # data: data.table format, analysed dataset / ID: character, name of the variable containing individual trip or vessel IDs - WARNING: when using the function with averaging at trip level the ID MUST take into account overlapping fishing trip (attributing it to a unique vessel => "vessel_ID" in our case) / value: character, name of the categorical variable for which we want to obtain the diversity index / method: character, selection of the diversity index ("simpson" or "shannon") / abundance: character, name of the variable being used as a proxy of categories' abundance (e.g. number of fishing events, trip, weight, effort, etc.) / constant: boolean, is the rule variable value (only for quantitative ones) constant over a fishing sequence ? (e.g. fishing effort) / event: character, name of variable indicating fishing sequence/event ID / averaged: boolean, is the number of categories averaged between different levels ? / scale: character, if averaged==T, name of the variable indicating the different levels to consider, e.g. trip or sequence IDs / SD: boolean, if TRUE return the Standard deviation between the different level 
    .ID=as.name(ID);
    .value=as.name(value);
    .abundance=as.name(abundance); #converting strings input in names
    if (!averaged) {
      eval( #evaluating the string command below
        substitute( #substituting strings by names
          data[!is.na(value) & !is.na(abundance),   #removing NAs to avoid taking them into account for the count number
                ifelse(!is.numeric(abundance), length( 
                  unique(abundance)), ifelse(constant, sum(abundance[!duplicated(event)]), sum(abundance))),  #number of occurence or sum per ID
                     by=.(ID,value)] [, ifelse(method=="simpson", diversity(V1, index="simpson"), diversity(V1, index="shannon")), #averaged/SD over ID
                                          by=ID ], list(ID=.ID, value=.value, abundance=.abundance)))
    }
    else {
      .scale=as.name(scale);
      eval(
        substitute(
          SACROIS[!is.na(value) & !is.na(abundance),
                    ifelse(!is.numeric(abundance), length( 
                      unique(abundance)), ifelse(constant, sum(abundance[!duplicated(event)]), sum(abundance))), #number of occurence per scale unit
                        by=.(ID,scale,value)] [, ifelse(method=="simpson", diversity(V1, index="simpson"), diversity(V1, index="shannon")), #averaged/SD over ID
                                          by=.(ID,scale) ] [, ifelse(SD, pop.sd(V1), mean(V1)), #averaged/SD over ID
                                          by=ID ], list(ID=.ID, value=.value, abundance=.abundance, scale=.scale)))
    }
  }
  
  
  
  
  
  
  #main categories (+proportion, values of main categories):
  

  
  
    main_cat <- function(data, ID, value, rule, constant=FALSE, event, majority=FALSE, averaged=FALSE, scale=NULL) { # data: data.table format, analysed dataset / ID: character, name of the variable containing individual trip or vessel IDs - WARNING: when using the function with averaging at trip level the ID MUST take into account overlapping fishing trip (attributing it to a unique vessel => "vessel_ID" in our case) / value: character, name of the categorical variable for which we want to determine the main category / rule: character, name of the variable being used to determine categories' importance (e.g. number of fishing events, trip, weight, effort, economic value, etc.) / constant: boolean, is the rule variable value (only for quantitative ones) constant over a fishing sequence ? (e.g. fishing effort) / event: character, name of variable indicating fishing sequence/event ID / majority: boolean, is the rule used to determine categories' importance used at different levels, for which a majority rule is applied then ? (i.e., main category determined for each trip/sequence, final main category is the one appearing the most over all trips/sequences) / averaged: boolean, is the rule used to determine categories' importance averaged between different levels ? / scale: character, if majority==T or averaged==T, name of the variable indicating the different levels to consider, e.g. trip or sequence IDs
    .ID=as.name(ID);
    .value=as.name(value);
    .event=as.name(event);
    .rule=as.name(rule); #converting strings input in names
    if (!averaged & !majority) {
      eval( #evaluating the string command below
        substitute( #substituting strings by names
          data[!is.na(value) & !is.na(rule)][,   #removing NAs to avoid taking them into account for the count number 
                ifelse(is.numeric(rule), ifelse(constant, sum(rule[!duplicated(event)]), sum(rule)), length(unique(rule))),  #number of "rule" occurrence per ID for non-numeric variables (i.e. trip or sequence ID) / sum of "rule" values per ID for numeric variables (while selecting only one fishing sequence occurrence for rule values constant over fishing sequence)
                     by=.(ID,value)] [, .(main=V1==max(V1), val=V1, prop=V1/sum(V1), value), #find maximal rule value per ID
                                          by=ID ] [main==T] [!duplicated(ID), .(ID, value, val, prop)], list(ID=.ID, value=.value, rule=.rule, event=.event))) #retaining category with maximal value, in case of ex-aequo retains the first category entered in logbook (random ???) 
    }
    else if (averaged) {
      .scale=as.name(scale);
      eval( #evaluating the string command below
        substitute( #substituting strings by names
          data[!is.na(value) & !is.na(rule)][,   #removing NAs to avoid taking them into account for the count number 
                ifelse(is.numeric(rule), ifelse(constant, sum(rule[!duplicated(event)]), sum(rule)), length(unique(rule))),  #number of "rule" occurrence per ID+scale for non-numeric variables (i.e. sequence ID) / sum of "rule" values per ID+scale for numeric variables (while selecting only one fishing sequence occurrence for rule values constant over fishing sequence)
                     by=.(ID, scale, value)] [, .(mean(V1), pop.sd(V1)), #mean of rule values per scale
                                              by=.(ID,value)] [, .(main=V1==max(V1), val=V1, sd=V2, prop=V1/sum(V1), value), #find maximal rule value per ID
                                              by=ID ] [main==T] [!duplicated(ID), .(ID,value, val, sd, prop)], list(ID=.ID, value=.value, rule=.rule, event=.event, scale=.scale))) #retaining category with maximal value, in case of ex-eaquo retains the first category entered in logbook (random ???) 
    }
    else if (majority) {
      .scale=as.name(scale);
      eval( #evaluating the string command below
        substitute( #substituting strings by names
          data[!is.na(value) & !is.na(rule)][,   #removing NAs to avoid taking them into account for the count number
                ifelse(is.numeric(rule), ifelse(constant, sum(rule[!duplicated(event)]), sum(rule)), length(unique(rule))),  #number of "rule" occurrence per ID+scale for non-numeric variables (i.e. sequence ID) / sum of "rule" values per ID+scale for numeric variables (while selecting only one fishing sequence occurrence for rule values constant over fishing sequence)
                     by=.(ID, scale, value)] [, .(main=V1==max(V1), val=V1, prop=V1/sum(V1), value), #find maximal rule value per ID+scale
                                              by=.(ID, scale) ] [main==T] [!duplicated(scale)] [, .(length(scale), val=mean(val), prop=mean(prop)), #number of scale for each scale-level main categories
                                              by=.(ID,value)] [, .(V1==max(V1), val=weighted.mean(val, V1), sd=weighted.mean( (val-weighted.mean(val, V1))^2, V1 ), prop=weighted.mean(prop, V1), sd_prop=weighted.mean( (prop-weighted.mean(prop, V1))^2, V1 ), value), #find categories with the more scale representation
                                          by=ID ] [V1==T] [!duplicated(ID), .(ID,value, val, sd, prop, sd_prop)] , list(ID=.ID, value=.value, rule=.rule, event=.event, scale=.scale))) #retaining category with maximal value, in case of ex-eaquo retains the first category entered in logbook (random ???) 
      }    
  }
  
    
    
    #WARNING: this function returns main categories AND their associated proportion and values. In the case of "averaged" or "majority" values and proportion it does not correspond to the mean/sd value/proportion of the determined main category, but respectively to the proportion of the mean value or the mean/sd value/proportion of each maximal value. Proportion and values for a unique category can be computed below 
    
    
    
    
    
    
    

    
    
    #second/third categories (+proportion, values of such categories):
    
    
    
    
    
    secondary_cat <- function(data, ID, value, rule, first, second=NULL, constant=FALSE, event) { # data: data.table format, analysed dataset / ID: character, name of the variable containing individual trip or vessel IDs - WARNING: when using the function with averaging at trip level the ID MUST take into account overlapping fishing trip (attributing it to a unique vessel => "vessel_ID" in our case) / value: character, name of the categorical variable for which we want to determine the main category / rule: character, name of the variable being used to determine categories' importance (e.g. number of fishing events, trip, weight, effort, economic value, etc.) / first, second: data.table containing trip, vessel IDs along with main or second categories (importance being determined with the same rules) / constant: boolean, is the rule variable value (only for quantitative ones) constant over a fishing sequence ? (e.g. fishing effort) / event: character, name of variable indicating fishing sequence/event ID 
    .ID=as.name(ID);
    .value=as.name(value);
    .event=as.name(event);
    .rule=as.name(rule); #converting strings input in names
    if (is.null(second)) {
      eval( #evaluating the string command below
        substitute( #substituting strings by names
          data[!is.na(value) & !is.na(rule)] [first[,.(ID, main=value)], #removing NAs to avoid taking them into account for the count number / merging reference level with dataset
                                      on= .(ID)] [value!=main,    
                ifelse(is.numeric(rule), ifelse(constant, sum(rule[!duplicated(event)]), sum(rule)), length(unique(rule))),  #number of "rule" occurrence per ID for non-numeric variables (i.e. trip or sequence ID) / sum of "rule" values per ID for numeric variables (while selecting only one fishing sequence occurrence for rule values constant over fishing sequence)
                     by=.(ID,value)] [, .(main=V1==max(V1), val=V1, prop=V1/sum(V1), value), #find maximal rule value per ID
                                          by=ID ] [main==T] [!duplicated(ID), .(ID, value, val, prop)], list(ID=.ID, value=.value, rule=.rule, event=.event))) #retaining category with maximal value, in case of ex-eaquo retains the first category entered in logbook (random ???) 
    }
    else {
      eval( #evaluating the string command below
        substitute( #substituting strings by names
          data[!is.na(value) & !is.na(rule)] [first[,.(ID, main=value)], #removing NAs to avoid taking them into account for the count number / merging reference level with dataset
                                      on= .(ID)] [second[,.(ID, second=value)], #removing NAs to avoid taking them into account for the count number / merging reference level with dataset
                                      on= .(ID)] [value!=main & value!=second,    
                ifelse(is.numeric(rule), ifelse(constant, sum(rule[!duplicated(event)]), sum(rule)), length(unique(rule))),  #number of "rule" occurrence per ID for non-numeric variables (i.e. trip or sequence ID) / sum of "rule" values per ID for numeric variables (while selecting only one fishing sequence occurrence for rule values constant over fishing sequence)
                     by=.(ID,value)] [, .(main=V1==max(V1), val=V1, prop=V1/sum(V1), value), #find maximal rule value per ID
                                          by=ID ] [main==T] [!duplicated(ID), .(ID, value, val, prop)], list(ID=.ID, value=.value, rule=.rule, event=.event))) #retaining category with maximal value, in case of ex-eaquo retains the first category entered in logbook (random ???) 
    }
  }  
  
    
    
    
    
    
    
    
  
  
  #proportion/values of categories:
    
  
  
  
    cat_prop_val <- function(data, ID, value, rule, reference, constant=FALSE, event, averaged=FALSE, scale=NULL) { # data: data.table format, analysed dataset / ID: character, name of the variable containing individual trip or vessel IDs - WARNING: when using the function with averaging at trip level the ID MUST take into account overlapping fishing trip (attributing it to a unique vessel => "vessel_ID" in our case) / value: character, name of the categorical variable for which we want to determine the proportion/value of a reference category / rule: character, name of the variable being used to determine categories' weight (e.g. number of fishing events, trip, weight, effort, economic value, etc.) / reference: character or data.table, reference level of the categorical variable of interest, for which we compute the value / proportion relatively to all other levels. Can either be a unique reference value applied to all vessels, or a data.table with reference value indicated for vessel/trip ID / constant: boolean, is the rule variable value (only for quantitative ones) constant over a fishing sequence ? (e.g. fishing effort) / event: character, name of variable indicating fishing sequence/event ID / averaged: boolean, is the rule used to determine categories' importance averaged between different levels ? / scale: character, if averaged==T, name of the variable indicating the different levels to consider, e.g. trip or sequence IDs
    .ID=as.name(ID);
    .value=as.name(value);
    .event=as.name(event);
    .rule=as.name(rule); #converting strings input in names
    if (is.character(reference)) {
    if (!averaged) {
      eval( #evaluating the string command below
        substitute( #substituting strings by names
          data[!is.na(value) & !is.na(rule)][,   #removing NAs to avoid taking them into account for the count number 
                ifelse(is.numeric(rule), ifelse(constant, sum(rule[!duplicated(event)]), sum(rule)), as.numeric(length(unique(rule)))),  #number of "rule" occurrence per ID for non-numeric variables (i.e. trip or sequence ID) / sum of "rule" values per ID for numeric variables (while selecting only one fishing sequence occurrence for rule values constant over fishing sequence)
                     by=.(ID,value)] [, .(ifelse(reference %in% .SD$value, V1[.SD$value==reference], 0), sum(V1)), #compute rule value proportion in class of interest
                                          by=ID ][,.(ID, val=V1, prop=V1/V2)], list(ID=.ID, value=.value, rule=.rule, event=.event))) 
    }
    else {
      .scale=as.name(scale);
      eval( #evaluating the string command below
        substitute( #substituting strings by names
          data[!is.na(value) & !is.na(rule)][,   #removing NAs to avoid taking them into account for the count number 
                ifelse(is.numeric(rule), ifelse(constant, sum(rule[!duplicated(event)]), sum(rule)), as.numeric(length(unique(rule)))),  #number of "rule" occurrence per ID for non-numeric variables (i.e. trip or sequence ID) / sum of "rule" values per ID for numeric variables (while selecting only one fishing sequence occurrence for rule values constant over fishing sequence)
                     by=.(ID, scale, value)] [, .(ifelse(reference %in% .SD$value, V1[.SD$value==reference], 0), sum(V1)), #compute rule value proportion in class of interest at the scale level
                                              by=.(ID,scale)] [, .(val=mean(V1), prop=mean(V1/V2)), #mean value per scale
                                              by=ID ], list(ID=.ID, value=.value, rule=.rule, event=.event, scale=.scale))) #retaining category with maximal value, in case of ex-eaquo retains the first category entered in logbook (random ???) 
    }
    }  
    else{
      if (!averaged) {
      eval( #evaluating the string command below
        substitute( #substituting strings by names
          data[!is.na(value) & !is.na(rule)][,   #removing NAs to avoid taking them into account for the count number 
                ifelse(is.numeric(rule), ifelse(constant, sum(rule[!duplicated(event)]), sum(rule)), as.numeric(length(unique(rule)))),  #number of "rule" occurrence per ID for non-numeric variables (i.e. trip or sequence ID) / sum of "rule" values per ID for numeric variables (while selecting only one fishing sequence occurrence for rule values constant over fishing sequence)
                     by=.(ID,value)] [reference[,.(ID, main=value)], #merging reference level with dataset
                                      on= .(ID)][, .(ifelse(.SD$main[1] %in% .SD$value, V1[.SD$value==.SD$main[1]], 0), sum(V1)),  #compute rule value proportion in class of interest
                                          by=ID ][, .(ID, val=V1, prop=V1/V2)], list(ID=.ID, value=.value, rule=.rule, event=.event))) 
    }
    else {
      .scale=as.name(scale);
      eval( #evaluating the string command below
        substitute( #substituting strings by names
          data[!is.na(value) & !is.na(rule)][,   #removing NAs to avoid taking them into account for the count number 
                ifelse(is.numeric(rule), ifelse(constant, sum(rule[!duplicated(event)]), sum(rule)), as.numeric(length(unique(rule)))), #number of "rule" occurrence per ID for non-numeric variables (i.e. trip or sequence ID) / sum of "rule" values per ID for numeric variables (while selecting only one fishing sequence occurrence for rule values constant over fishing sequence)
                     by=.(ID, scale, value)] [reference[,.(ID, main=value)], #merging reference level with dataset
                                      on= .(ID)][, .(ifelse(.SD$main[1] %in% .SD$value, V1[.SD$value==.SD$main[1]], 0), sum(V1)), #compute rule value proportion in class of interest at the scale level
                                              by=.(ID,scale)] [, .(val=mean(V1), sd=pop.sd(V1), prop=mean(V1/V2), sd_prop=pop.sd(V1/V2)), #mean value per scale
                                              by=ID ], list(ID=.ID, value=.value, rule=.rule, event=.event, scale=.scale))) #retaining category with maximal value, in case of ex-eaquo retains the first category entered in logbook (random ???) 
    }
    }
  }
  
    
    
    
    
    
    
    
    
    
    
    
  
  #quantitative value:
  
    
    
    
    
    
  
  
    quant_values <- function(data, ID, value, constant=FALSE, event, averaged=FALSE, averaged2=FALSE, scale=NULL, scale2=NULL, SD=FALSE, SD2=FALSE, weighted=NULL) { # data: data.table format, analysed dataset / ID: character, name of the variable containing individual trip or vessel IDs - WARNING: when using the function with averaging at trip level the ID MUST take into account overlapping fishing trip (attributing it to a unique vessel => "vessel_ID" in our case) / value: numeric, name of the quantitative variable for which we want to determine the value/variation at different possible scale / constant: boolean, is the quantitative variable constant over a fishing sequence ? (e.g. fishing effort) / event: character, name of variable indicating fishing sequence/event ID / averaged, averaged2: booleans, is the rule used to determine categories' importance averaged between different levels ? (could be performed up to two different level at the same time) / scale, scale2: character, if averaged==T, name of the variable indicating the different levels to consider, e.g. trip, sequence IDs, taxa... / SD,SD2: booleans, if TRUE return the Standard deviation between the different level considered 
    .ID=as.name(ID);
    .value=as.name(value);
    .event=as.name(event); #converting strings input in names
    if (!averaged) {
      eval( #evaluating the string command below
        substitute( #substituting strings by names
          data[!is.na(value)][if (constant) {!duplicated(event)} else {1:.N},   #removing NAs to avoid taking them into account / selecting only one fishing sequence occurrence for values constant over fishing sequence
                sum(value),  #sum of values per ID
                     by=ID], list(ID=.ID, value=.value, event=.event))) 
    }
    else if (!averaged2) {
      .scale=as.name(scale);
      if (is.null(weighted)) {
        eval( #evaluating the string command below
          substitute( #substituting strings by names
            data[!is.na(value) & !is.na(scale)][,   #removing NAs to avoid taking them into account
                  ifelse(constant, sum(value[!duplicated(event)]), sum(value)),  #sum of values per ID and scale (selecting only one fishing sequence occurrence for values constant over fishing sequence)
                       by=.(ID, scale)] [, ifelse(SD, pop.sd(V1), mean(V1)), #averaging per scale
                                         by=ID], list(ID=.ID, value=.value, event=.event, scale=.scale))) 
      }
      else { #only applicable for quantitative values with baseline level at the event scale and for averaging at the same event scale
        .weighted=as.name(weighted);
        eval( #evaluating the string command below
          substitute( #substituting strings by names
            data[!is.na(value) & !is.na(weighted)][,   #removing NAs to avoid taking them into account
                  .(value[!duplicated(event)], ifelse(constant, sum(value[!duplicated(event)]), sum(value))),  #sum of values per ID and scale (selecting only one fishing sequence occurrence for values constant over fishing sequence)
                       by=.(ID, scale)] [, ifelse(SD, weighted.mean( (V1-weighted.mean(V1, V2))^2, V2 ), weighted.mean(V1, V2)), #averaging per scale
                                         by=ID], list(ID=.ID, value=.value, event=.event, scale=.scale, weighted=.weighted))) 
      }
    }  
    else {
      .scale=as.name(scale);
      .scale2=as.name(scale2);
      eval( #evaluating the string command below
        substitute( #substituting strings by names
          data[!is.na(value) & !is.na(scale)][,   #removing NAs to avoid taking them into account 
                ifelse(constant, sum(value[!duplicated(event)]), sum(value)),  #sum of values per ID and scale (selecting only one fishing sequence occurrence for values constant over fishing sequence)
                     by=.(ID, scale, scale2)] [, ifelse(SD, pop.sd(V1), mean(V1)), #averaging per first scale
                                       by=.(ID, scale)] [, ifelse(SD2, pop.sd(V1), mean(V1)), #averaging per second scale
                                       by=ID], list(ID=.ID, value=.value, event=.event, scale=.scale, scale2=.scale2))) 
    }
  }
  
    
    
    
    
    
  

```








## Data acquisition

We need first to retrieve the data from their original location, and process it to keep only the information of interest (fished species, fishing engines, fishing zones, fishing activity, economic activity, as well as the vessels' characteristics). In a standardized framework input data should have the same format than what we used here.

```{r retrieve data}

#1) First step: extracting all vessels' data per year, selecting variables of interest for our classification, selecting vessels operating in our area of interest (Bay of Biscay), sum up data per year and per vessel, concatenate all data

#vessels operating in the Bay of Biscay are defined as vessels with at least one fishing event in the bay of Biscay (areas 27.8.a and 27.8.b), all fishing operation (including outside of the Bay of Biscay) are then considered for the classification into fleets(to avoid misclassification of vessels operating a certain way only in the bay that is not consistent with their original specifities) 





#data treatment from 2000 to 2022 :

SACROIS=data.table()



for (i in 2000:2023) {  #the year 2023 is included to take into account the marees beginning in 2022 and ending in 2023 (including not negligible amount of data about the end of 2022)
  
  setwd(paste0('~/Data/SACROIS/',i));
  
  SACROIS<-rbind(fread(paste0("NAVIRES-MOIS-MAREES-JOUR-IFR_",i,".txt"), dec=",", select= c("NAVS_COD","MAREE_ID","PAVILLON","LIEU_COD_DEP_SACROIS","LIEU_COD_RET_SACROIS","TPS_MER", "SEQ_ID","DATE_SEQ","METIER_COD_SACROIS","ENGIN_COD","MAILLAGE","DIMENSION","SECT_COD_SACROIS_NIV3","SECT_COD_SACROIS_NIV4","SECT_COD_SACROIS_NIV5","SECT_COD_SACROIS_NIV6","GRADIENT_COD","ZEE_COD","TP_NAVIRE_SACROIS","CAPT_ID","ESP_COD_FAO","STOCK_ORGP","QUANT_POIDS_VIF_SACROIS","MONTANT_EUROS_SACROIS")), SACROIS);
  
  SACROIS=SACROIS[NAVS_COD!="",];         #removal of vessels without id
  
  SACROIS[,NAVS_COD_YEAR:=paste(SACROIS[,NAVS_COD], str_sub(SACROIS[,DATE_SEQ],7,10), sep="_")];   #produce a unique ID per vessel ad per year
  
  select_biscay=
    tapply(SACROIS[,SECT_COD_SACROIS_NIV3], SACROIS[,NAVS_COD_YEAR],
                     function(x) ("27.8.a" %in% x | "27.8.b" %in% x) );
  
  SACROIS=
    SACROIS[NAVS_COD_YEAR %in% names(select_biscay[select_biscay]),];      #selection of vessels with activity in the bay of biscay (discarding vessels the years they have no activity in the bay of Biscay)
  
  SACROIS[,NAVS_COD_YEAR:=NULL]     #removing the extra column to be able to bind data table
}


SACROIS[,NAVS_COD_YEAR:=paste(SACROIS[,NAVS_COD], str_sub(SACROIS[,DATE_SEQ],7,10), sep="_")]  #produce a unique ID per vessel ad per year





#minimal requirement for being able to run the previous section: 32GB of RAM



#important notice: the last studied year (here 2022) does not take into account overlapping marees (between this year and the following one): have to be corrected by taking the following year into account during computation and then removing it at the end !!!! Important to do  because represent a non-negligible amount of data at the end of the year






#intermediary steps (selection vessels with valid IDs, selection of active vessels) are not necessary at this level (time consuming to do it for each year, would be faster if performed after in a row) but are mandatory here due to limited available memory


rm(select_biscay)
gc() #garbage collection, free unused memory usage




#Variables choices:
# - data may vary in their accuracy according to the way they have been collected, for the moment we will consider that the work performed by SACROIS is sufficiently well done to not consider the data origins, or metrics indicating how data sources overlap
# - the existing metier and fleet classification will be kept to compare the final classification with the previous ones
# - when different estimation methods co-exist for a same metric we always favored the SACROIS method (except for engines because in this particular case SACROIS estimates used engines from an algorithm using complex rule of decision and not directly from observations or declarations, to avoid any influence from other classifications we set apart this estimation)
# - position data at the fishing position level (statistical unit, SECT_COD_NIV7) is too imprecise to be used (massive amount of missing data). No interest of using position data below ICES division precision (SECT_COD_SACROIS_NIV3<,not sufficiently precise) 








library(dplyr)
library(arrow)

ds<-open_dataset("C:/Users/mbrevet/Documents/Data/SACROIS/simplesacrois")

ds<-ds%>%filter(AN %in% 2000:2023)%>%
      filter(SEQ_ID %in% unique(SACROIS[,SEQ_ID])) %>%
      select(SEQ_ID, TP_NAVIRE_SACROIS) %>%collect

setDT(ds)


ds=ds[!duplicated(ds$SEQ_ID),]


table(is.na(ds[,TP_NAVIRE_SACROIS])) #~27% of missing values (almost equivalent proportion to what observed in the actual effort metrics)


#setdiff(SACROIS[!duplicated(SEQ_ID),SEQ_ID], ds[,SEQ_ID])




# problematic issue: missing fishing sequences in the "simplesacrois" files (from 2019 to 2022: 14 786 sequences, i.e. ~1% of data, with the vast majority missing in 2022, i.e. 98.5% representing ~4% of sequences in 2022, and some missing values in 2021)




colnames(ds)[2]="TP_NAVIRE_SACROIS_CORR"
SACROIS=merge(SACROIS, ds, all.x=T)

# Recovery of effort data corrected for SACROIS


rm(ds)
gc()




#Checking if there is no duplicated lines:

any(duplicated(SACROIS))







#2) Second step: extracting the data on the vessels' characteristics for all retained vessels






FPC=data.table()



for (i in 2000:2023) {
  
  setwd(paste0('~/Data/SACROIS/',i));
  
  FPC<-rbind(fread(dir(getwd(), pattern="ISIH-504549-vueAnnuelleFpc"), dec=",", encoding="Latin-1", select= c("NAVS_COD","DATE_REF","QAM_COD","SRG_COD","PORT_EXPL_ACT_COD","CARN_AGE","NAVP_LONGUEUR_HT","NAVP_JAUGE_GT","NAVP_PUISSANCE_AD","ARM_AGE","CARN_EFFECTIF","NB_MOIS_ACT","RA_ACT_LIB","ENG1","ENG2","FLOTTILLE_IFREMER_LIB","S_FLOTTILLE_IFREMER_LIB","S_S_FLOTTILLE_IFREMER_LIB","DCR_GRANDE_FLOTTILLE_LIB","DCR_SEGMENT_CE_LIB","DCR_FLOTTILLE_LIB","DCR_S_FLOTTILLE_LIB","DCR_S_S_FLOTTILLE_LIB","ART_RESTIT_LIB","FLOTTILLE_RESTIT_LIB","S_FLOTTILLE_RESTIT_LIB","S_S_FLOTTILLE_RESTIT_LIB","BZH_FLOTTILLE_LIB","BZH_S_FLOTTILLE_LIB")), FPC)
}


FPC$NAVS_COD_YEAR=paste(FPC[,NAVS_COD], str_sub(FPC[,DATE_REF],7,10), sep="_")  #produce a unique ID per vessel ad per year


FPC[,c("DATE_REF", "NAVS_COD"):=NULL]


FPC=FPC[NAVS_COD_YEAR %in% unique(SACROIS[,NAVS_COD_YEAR]),]       #selection of retained vessels





#Variables choices:
#-some variables bring new information on vessels characteristics through surveys or administrative declaration (vessels' size, age, tonnage, engine power, size of the crew)
#-other variables are also accessible from SACROIS, but may be more precise due to data on surveys that may compensate inaccuracy common in SACROIS data (main harbor, exploited regions, period and zone of activity, used fishing engines)
# => the latter variables could be optional in the final version for better reproducibility ? (not sure about availability of these data + redundant compared to global data based information from SACROIS)
#- we also retained all data on fleet classification that had been previously made (IFREMER, DCR, Art, Restitution and BZH fleets), to compare them to the classification we will achieve here







#3) Third step: creation of a new data frame containing data per vessel and adding yearly activity metrics (fishing effort, amount of captured fishes corrected by fishing effort, absolute amount of fish, proportion of fished species, seasonal activity, geographical distribution: time spent in each area / percentage of occupation of each area / activity in each area, economic activity, engine activity: mesh and net size / type of net) 


data_vessel=data.table(unique(SACROIS[,NAVS_COD_YEAR]))

colnames(data_vessel)<-"NAVS_COD_YEAR"




#Inclusion of ship characteristics (FPC file):


data_vessel=merge(data_vessel, FPC, all.x=T)

remove(FPC) # removes table without any more use, to avoid memory overload
gc()


```




###Taxon definition

We first more precisely described the fished taxa.


```{r Fished taxa}

SACROIS[ESP_COD_FAO=="",ESP_COD_FAO:=NA]






setwd("~/Data/SACROIS")

Code_FAO<-fread("ISIH-504549-espece_fao-20230320105303.txt")





setdiff(SACROIS[,ESP_COD_FAO], Code_FAO[,ESPF_COD]) # check whether there is FAO code without correspondence in the SACROIS dataset ==> this is the case only for "ZZ9" (=species out of context), corresponding to non-commercial species (marine birds, snakes...)


#five classification levels are registered in the FAO nomenclature: 1) species, 2) group of species (warning: not equal to genus), 3) family, 4) order, 5) commercial group of species (code ISSCAP) (warning: in most of cases a code ISSCAP include several family and order, but in some cases reverse is also true)

#warning: group of species classification does not always exist (if it does not: keep the species level)

#warning: the classification is sometimes phylogenetically inaccurate (para- or poly-phyletic: groupment of two families or species, incomplete order), they are labelled by supplementary numbers after "X" notations in the "taxon code" column





SACROIS=merge(SACROIS, Code_FAO[, .(ESPF_COD,ESPF_TAXON_COD)], by.x="ESP_COD_FAO", by.y ="ESPF_COD", all.x = T, all.y=F, sort=F ) #add a column with the species specific FAO code (information on the taxon level through the number of "X" present in the code)


SACROIS[ESP_COD_FAO!="ZZ9" & !is.na(ESP_COD_FAO), taxon_precision := lapply(.SD, function(x) str_count(x, "X")), .SDcols = "ESPF_TAXON_COD"] # assign the best level of precision for the taxonomic classification (0: species / 2: group of species / 5: family / 7: order)


SACROIS[,ESPF_TAXON_COD:=NULL] #removing extracolumns


# in 2023, 85% of cases: species precision / 95%: group of species precision / order precision: only 0.5% (mainly concerns crustaceans, urchins and flatfishes)   



# Creation of a new column, specific to commercial species, with attribution of NA values when not knowing the fished (non-commercial) species:   (these species could be studied through accidental bycatch files)

SACROIS[taxon_precision==0, ESP2_COD_FAO:=ESP_COD_FAO]



#Warning: some species have been attributed to different families in columns "ESPF_SCI_LIB" and "FAMILLE" (due to recent discussions on the taxonomy), in such cases the most recent classification was applied, corrected below:


Code_FAO[ESPF_COD=="USK",FAMILLE:="Gadidae"]

Code_FAO[ESPF_COD=="CRG",FAMILLE:="Portunidae"]


Code_FAO[ESPF_COD=="LIO",ESPF_PARENT_SCI_LIB:="Polybiidae"]

Code_FAO[ESPF_COD == "TJX",FAMILLE:="Scorpaenidae"]

Code_FAO[ESPF_COD == "CFB",ESPF_PARENT_SCI_LIB:="Etmopteridae"]

Code_FAO[ESPF_COD == "SLI",ESPF_PARENT_SCI_LIB:="Molva spp"]

Code_FAO[ESPF_COD == "LNZ",ESPF_PARENT_SCI_LIB:="Lotidae"]

Code_FAO[ESPF_COD == "IOD",ESPF_PARENT_SCI_LIB:="Polybiidae"]

Code_FAO[ESPF_COD == "ATB",FAMILLE:="Atherinidae"] #wrong attribution of a subfamily




Code_FAO[FAMILLE=="Parechinidae",ESPF_PARENT_SCI_LIB:="Parechinidae"]

Code_FAO[FAMILLE=="Somniosidae" & ESPF_PARENT_SCI_LIB=="Squalidae", ESPF_PARENT_SCI_LIB:="Somniosidae"]

Code_FAO[FAMILLE=="Dalatiidae", ESPF_PARENT_SCI_LIB:="Dalatiidae"]








SACROIS=merge(SACROIS, Code_FAO[, .(ESPF_COD,ESPF_SCI_LIB,ESPF_PARENT_SCI_LIB,FAMILLE)], by.x="ESP_COD_FAO", by.y ="ESPF_COD", all.x = T, all.y=F, sort=F) # addition in the dataset of the columns: 1) scientific name of the taxon, 2) scientific names of the taxon upper the taxon of interest, 3) Taxonomic family of the taxon of interest



#"SPP_COD_FAO" attribute group of species taxon level:

SACROIS[taxon_precision==2, SPP_COD_FAO:=ESPF_SCI_LIB] #when the FAO code correspond to a group of species, attribution of the scientific name of the group

SACROIS[taxon_precision==0, SPP_COD_FAO:=ESPF_PARENT_SCI_LIB] #when the FAO code correspond to a species, attribution to the upper taxon name (i.e. group of species, with some exceptions => see next line)

SACROIS[SPP_COD_FAO==FAMILLE, SPP_COD_FAO:=ESPF_SCI_LIB] #in the specific cases where the upper taxonomic group is beyond the group of species level (directly family level) or is not informed, re-attribution of the species name (considered as a group of species in itself)



SACROIS[,ESPF_PARENT_SCI_LIB:=NULL] #removing extracolumns


##Another way of writing it (but more than a hundred time less efficient as assessed by microbenchmark):
#SACROIS[, SPP_COD_FAO2 := ifelse(taxon_precision==2, ESPF_SCI_LIB, ifelse( taxon_precision==0 & ESPF_PARENT_SCI_LIB==FAMILLE, ESPF_SCI_LIB, ifelse(taxon_precision==0 & ESPF_PARENT_SCI_LIB!=FAMILLE, ESPF_PARENT_SCI_LIB, NA)))]




#in the bay of biscay there is only two Alosa present: therefore we can group "Alosa spp" and "Alosa alosa, A. fallax" categories:


SACROIS[SPP_COD_FAO=="Alosa alosa, A. fallax",SPP_COD_FAO:="Alosa spp"]

SACROIS[SPP_COD_FAO=="Anguilla anguilla",SPP_COD_FAO:="Anguilla spp"] #groupment of all developmental stage of Anguilla anguilla (in ESP_COD_FAO differentiation between juvenile, early and late adult phase, WARNING: this differentiation is not systematic)


SACROIS[SPP_COD_FAO=="Chelidonichthys cuculus",SPP_COD_FAO:="Chelidonichthys spp"] #attribution of red gurnard with the rest of gurnard spp

SACROIS[SPP_COD_FAO=="Scomber colias",SPP_COD_FAO:="Scomber spp"] #attribution of Atlantic chub mackerel with the rest of mackerel spp








#"FAMILY_COD_FAO" attribute family taxon level:

SACROIS[taxon_precision==5, FAMILY_COD_FAO:=ESPF_SCI_LIB] #when the FAO code correspond to a family, attribution of the scientific name of the family

SACROIS=merge(SACROIS, Code_FAO[, .(ESPF_SCI_LIB,ESPF_PARENT_SCI_LIB)], by.x="SPP_COD_FAO", by.y ="ESPF_SCI_LIB", all.x = T, all.y=F, sort=F) #add a column with the scientific name of the taxon upper the group of species category

SACROIS[taxon_precision<5, FAMILY_COD_FAO:=ESPF_PARENT_SCI_LIB] #assign the family when the group of species class is known


SACROIS[,c("ESPF_PARENT_SCI_LIB", "FAMILLE"):=NULL] #removing extracolumns


SACROIS[FAMILY_COD_FAO=="Thunnini", FAMILY_COD_FAO:="Scombridae"]
#correction of errors in dataset: some individuals were classified as "Thunnini" at the family level while it is a tribe taxon not a family (right family: Scombridae)




#in some cases two families are grouped (Sepiidae, Sepiolidae / Loliginidae, Ommastrephidae), these categories were kept as such (but maybe the two families at stake could be regrouped in this category), and an order was attributed to them:

Code_FAO[ESPF_PARENT_SCI_LIB=="Sepiidae, Sepiolidae" | ESPF_SCI_LIB=="Sepiidae, Sepiolidae",ORDRE:="Sepiida"]

Code_FAO[Code_FAO$ESPF_PARENT_SCI_LIB=="Loliginidae, Ommastrephidae" | Code_FAO$ESPF_SCI_LIB=="Loliginidae, Ommastrephidae",ORDRE:="Myopsida, Oegopsida"]

Code_FAO[ESPF_PARENT_SCI_LIB=="Squalidae, Scyliorhinidae", ORDRE:="Squaliformes, Carcharhiniformes"]







#the order is poorly informed in the FAO table, it sometimes appears for one specific taxon level and not for the others, the upper taxon level relatively to the family level was not used because it contains both order and suborder categories 


SACROIS[taxon_precision==7, ORDER_COD_FAO:=ESPF_SCI_LIB] #when the FAO code correspond to an order, attribution of the scientific name of the order

SACROIS=merge(SACROIS, Code_FAO[, .(ESPF_SCI_LIB,ORDRE)], by.x="SPP_COD_FAO", by.y ="ESPF_SCI_LIB", all.x = T, all.y=F, sort=F)



Code_FAO[ESPF_COD =="FGX",ESPF_SCI_LIB:="Gobiidae (Freshwater)"]
Code_FAO[ESPF_COD =="PPZ",ESPF_SCI_LIB:="Palaemonidae (Freshwater)"]


SACROIS=merge(SACROIS, Code_FAO[, .(ESPF_SCI_LIB,ORDRE)], by.x="FAMILY_COD_FAO", by.y ="ESPF_SCI_LIB", all.x = T, all.y=F, sort=F, no.dups=T)
#attribute order at the different taxa level (to compensate for incomplete data)


SACROIS[,ORDRE.y:=ORDRE.y[!is.na(ORDRE.y)][1], by=.(FAMILY_COD_FAO)]#Attribute the same order to all species in the same family



SACROIS[taxon_precision<7, ORDER_COD_FAO:=ORDRE.x]


SACROIS[taxon_precision<7 & is.na(ORDER_COD_FAO), ORDER_COD_FAO:=ORDRE.y]



SACROIS[,c("ESPF_SCI_LIB", "ORDRE.x","ORDRE.y"):=NULL] #removing extracolumns



#Correction of some attribution errors:

SACROIS[ORDER_COD_FAO=="Brachyura",ORDER_COD_FAO:="Decapoda" ]#suborder to order

SACROIS[ORDER_COD_FAO=="Siluroidei",ORDER_COD_FAO:="Siluriformes"] #suborder to order

SACROIS[ORDER_COD_FAO=="Clupeoidei",ORDER_COD_FAO:="Clupeiformes"] #suborder to order

SACROIS[ORDER_COD_FAO=="Salmonoidei",ORDER_COD_FAO:="Salmoniformes"] #suborder to order


SACROIS[FAMILY_COD_FAO=="Mactridae",ORDER_COD_FAO:="Venerida"]

SACROIS[FAMILY_COD_FAO=="Patellidae",ORDER_COD_FAO:="Patellogastropoda"]

SACROIS[FAMILY_COD_FAO=="Haliotidae",ORDER_COD_FAO:="Vetigastropoda"]




#Warning: the order classification mix order groups, with class (Actinopterygii, Cephalopoda, Bivalvia, Scyphozoa), supra-order (Selachimorpha (Pleurotremata)) and subphylum (Crustacea, Echinoidea), there is also obsolete, paraphyletic groups (e.g. Reptantia/Natantia, Algae)


#before publication: need to correct the huge amount of phylogenetic errors ? (re-attribution to right groups / harmonization of order in the same taxonomic level, i.e. removing too high level ? risk of losing specific fisheries, e.g. Echinoidea)




SACROIS=merge(SACROIS, Code_FAO[, .(ESPF_COD,ESPF_ISSCAP)], by.x="ESP_COD_FAO", by.y ="ESPF_COD", all.x = T, all.y=F, sort=F)

SACROIS[!is.na(taxon_precision), ISSCAAP_COD_FAO:=ESPF_ISSCAP] #attribute the corresponding ISCAAP code for each species


SACROIS[,ESPF_ISSCAP:=NULL] #removing extracolumns





rm(Code_FAO)
gc()




```












## Creation of a set of detailed variables


From the initial variables we retained, we then create new variables describing the fishing activity per vessel and per year. Some of these variables simply describe the constant characteristics of the vessel within a year, while others describe how some fishing activity variable value behave along the year (average value, main categories, variation in values, etc.).





```{r fishing behaviour - vessel scale}


  #table de relation noms variables-noms clés:

  nomenclature=data.table(var=c("MAREE_ID", "LIEU_COD_DEP_SACROIS", "LIEU_COD_RET_SACROIS", "TPS_MER", "SEQ_ID", "ENGIN_COD",  "MAILLAGE", "DIMENSION", "SECT_COD_SACROIS_NIV3", "SECT_COD_SACROIS_NIV5", "SECT_COD_SACROIS_NIV6", "GRADIENT_COD", "GRADIENT_COD2", "ZEE_COD",  "TP_NAVIRE_SACROIS", "TPS_MER", "ESP2_COD_FAO", "SPP_COD_FAO", "FAMILY_COD_FAO", "ORDER_COD_FAO", "ISSCAAP_COD_FAO",  "STOCK_ORGP",  "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO", "DATE_SEQ_DAY", "MONTH", "TRIMESTRE"), keys=c("effort_fishing_trip", "spat_dep_port", "spat_ret_port", "effort_sea_time", "effort_fishing_sequence", "gear_type", "gear_mesh_size", "gear_dimension", "spat_ICES_divis", "spat_stat_rect", "spat_stat_subrect", "spat_gradient", "spat_gradient", "spat_zee", "effort_fishing_time", "effort_sea_time", "tax_spe", "tax_spp", "tax_family", "tax_order", "tax_isscaap", "tax_stock", "weight", "eco", "weight.prod", "eco.prod", "temp_day", "temp_month", "temp_trimester"))








#an important feature to optimize these functions is to avoid to repeat heavy processes, for that reasons it is ESSENTIAL to define the "corrected" vessel ID for computation implying fishing trips (i.e. the vessel ID attributed to the whole fishing trip, including when it overlap two consecutive year, by giving the vessel ID with which the fishing trip begin with):


SACROIS[order(MAREE_ID, NAVS_COD_YEAR), vessel_ID:=NAVS_COD_YEAR[1], by=MAREE_ID]


#WARNING: trip and sequence/event ID must be in character/factor format !


SACROIS[, MAREE_ID:=as.character((MAREE_ID))]
SACROIS[, SEQ_ID:=as.character((SEQ_ID))]

SACROIS[, ESP2_COD_FAO:=as.character((ESP2_COD_FAO))]
SACROIS[, SPP_COD_FAO:=as.character((SPP_COD_FAO))]
SACROIS[, FAMILY_COD_FAO:=as.character((FAMILY_COD_FAO))]
SACROIS[, ORDER_COD_FAO:=as.character((ORDER_COD_FAO))]
SACROIS[, ISSCAAP_COD_FAO:=as.character((ISSCAAP_COD_FAO))]


  
  

  
  
  #WARNING: trip and sequence/event ID must be in character/factor format !
  
  
  SACROIS[, MAREE_ID:=as.character((MAREE_ID))]
  SACROIS[, SEQ_ID:=as.character((SEQ_ID))]
  
  
  
  
  #creation of temporal variables:
  
  
  
SACROIS[, TRIMESTRE:=as.integer(str_sub(DATE_SEQ,4,5))]
    
SACROIS[, TRIMESTRE:=as.integer(str_sub(DATE_SEQ,4,5))]
    
SACROIS[TRIMESTRE %in% c(1,2,3), TRIMESTRE:=1]
SACROIS[TRIMESTRE %in% c(4,5,6), TRIMESTRE:=2]
SACROIS[TRIMESTRE %in% c(7,8,9), TRIMESTRE:=3]
SACROIS[TRIMESTRE %in% c(10,11,12), TRIMESTRE:=4]
    

        
SACROIS[, MONTH:=as.integer(str_sub(DATE_SEQ,4,5))]





year=c(0,31,28,31,30,31,30,31,31,30,31,30,31) #days per month plus an initial 0


    

SACROIS[, DATE_SEQ_DAY:=
            sapply(.SD$DATE_SEQ, function(x) as.integer(str_sub(x,1,2))+sum(year[ 1:as.integer(str_sub(x,4,5)) ]) ) ] #displays the date in number of days since the beginning of the year





  
  
  
  #creation of a modified gradient variable:
  
  SACROIS[, GRADIENT_COD2:=GRADIENT_COD]
  SACROIS[GRADIENT_COD2 %in% c("3-12M","3M","F","GLE","I"), GRADIENT_COD2:="C"]










###### Diversity metrics



 
### richness
  
  
  
  

  for (i in c("MAREE_ID", "SEQ_ID", "ENGIN_COD",  "MAILLAGE", "DIMENSION", "SECT_COD_SACROIS_NIV3", "SECT_COD_SACROIS_NIV5", "SECT_COD_SACROIS_NIV6", "GRADIENT_COD", "ZEE_COD", "ESP2_COD_FAO", "SPP_COD_FAO", "FAMILY_COD_FAO", "ORDER_COD_FAO", "ISSCAAP_COD_FAO", "STOCK_ORGP")) {
    number_cats= number_cat(SACROIS, "NAVS_COD_YEAR", i);
    data_vessel=merge(data_vessel, number_cats, all=T);
    setnames(data_vessel, "V1", paste("div_nb_val", nomenclature[var==i, keys], "year", sep="_"))
  }



  for (i in c("SEQ_ID", "ENGIN_COD",  "MAILLAGE", "DIMENSION", "SECT_COD_SACROIS_NIV3", "SECT_COD_SACROIS_NIV5", "SECT_COD_SACROIS_NIV6", "GRADIENT_COD", "ZEE_COD", "ESP2_COD_FAO", "SPP_COD_FAO", "FAMILY_COD_FAO", "ORDER_COD_FAO", "ISSCAAP_COD_FAO", "STOCK_ORGP")) {
    number_cats= number_cat(SACROIS, "vessel_ID", i, averaged = T, scale = "MAREE_ID");
    data_vessel=merge(data_vessel, number_cats, all=T, by.x="NAVS_COD_YEAR", by.y="vessel_ID");
    setnames(data_vessel, "V1", paste("div_nb_val", nomenclature[var==i, keys], "average_trip", sep="_"))
  }




  for (i in c("SEQ_ID", "ENGIN_COD",  "MAILLAGE", "DIMENSION", "SECT_COD_SACROIS_NIV3", "SECT_COD_SACROIS_NIV5", "SECT_COD_SACROIS_NIV6", "GRADIENT_COD", "ZEE_COD", "ESP2_COD_FAO", "SPP_COD_FAO", "FAMILY_COD_FAO", "ORDER_COD_FAO", "ISSCAAP_COD_FAO", "STOCK_ORGP")) {
    number_cats= number_cat(SACROIS, "vessel_ID", i, averaged = T, scale = "MAREE_ID", SD=T);
    data_vessel=merge(data_vessel, number_cats, all=T, by.x="NAVS_COD_YEAR", by.y="vessel_ID");
    setnames(data_vessel, "V1", paste("div_nb", nomenclature[var==i, keys], "sde_trip", sep="_"))
  }





  for (i in c("ESP2_COD_FAO", "SPP_COD_FAO", "FAMILY_COD_FAO", "ORDER_COD_FAO", "ISSCAAP_COD_FAO", "STOCK_ORGP")) {
    number_cats= number_cat(SACROIS, "NAVS_COD_YEAR", i, averaged = T, scale = "SEQ_ID");
    data_vessel=merge(data_vessel, number_cats, all=T);
    setnames(data_vessel, "V1", paste("div_nb_val", nomenclature[var==i, keys], "average_seq", sep="_"))
  }




  for (i in c("ESP2_COD_FAO", "SPP_COD_FAO", "FAMILY_COD_FAO", "ORDER_COD_FAO", "ISSCAAP_COD_FAO", "STOCK_ORGP")) {
    number_cats= number_cat(SACROIS, "NAVS_COD_YEAR", i, averaged = T, scale = "SEQ_ID", SD=T);
    data_vessel=merge(data_vessel, number_cats, all=T);
    setnames(data_vessel, "V1", paste("div_nb", nomenclature[var==i, keys], "sde_seq", sep="_"))
  }






  #on specific subset:


    for (i in c("SECT_COD_SACROIS_NIV3", "GRADIENT_COD2", "MONTH", "TRIMESTRE")) {
      for (j in c("ESP2_COD_FAO", "FAMILY_COD_FAO", "ENGIN_COD")) {
        if (i=="SECT_COD_SACROIS_NIV3") {
          for (k in c("27.8.a", "27.8.b")) {
                number_cats= number_cat(SACROIS[eval(as.name(i))==k], "NAVS_COD_YEAR", j);
                data_vessel=merge(data_vessel, number_cats, all=T);
                setnames(data_vessel, "V1", paste("DIV", toupper(nomenclature[var==i, keys]), "nb", nomenclature[var==j, keys], k, sep="_"))
          }
        }
        else {
          for (k in unique(SACROIS$i)) {
                number_cats= number_cat(SACROIS[eval(as.name(i))==k], "NAVS_COD_YEAR", j);
                data_vessel=merge(data_vessel, number_cats, all=T);
                setnames(data_vessel, "V1", paste("DIV", toupper(nomenclature[var==i, keys]), "nb", nomenclature[var==j, keys], k, sep="_"))
          }
        }
      }
    }




    for (i in c("MONTH", "TRIMESTRE")) {
      for (j in c("SECT_COD_SACROIS_NIV3", "SECT_COD_SACROIS_NIV5")) {
          for (k in unique(SACROIS$i)) {
                number_cats= number_cat(SACROIS[eval(as.name(i))==k], "NAVS_COD_YEAR", j);
                data_vessel=merge(data_vessel, number_cats, all=T);
                setnames(data_vessel, "V1", paste("DIV", toupper(nomenclature[var==i, keys]), "nb", nomenclature[var==j, keys], k, sep="_"))
          }
      }
    }







  



### simpson


  

  for (i in c("ENGIN_COD",  "MAILLAGE", "DIMENSION", "SECT_COD_SACROIS_NIV3", "SECT_COD_SACROIS_NIV5", "SECT_COD_SACROIS_NIV6", "GRADIENT_COD", "ZEE_COD", "ESP2_COD_FAO", "SPP_COD_FAO", "FAMILY_COD_FAO", "ORDER_COD_FAO", "ISSCAAP_COD_FAO", "STOCK_ORGP")) {
    for (j in c("MAREE_ID", "SEQ_ID", "QUANT_POIDS_VIF_SACROIS", "TP_NAVIRE_SACROIS")) {
      div_cats= div_index(SACROIS, "NAVS_COD_YEAR", i, abundance=j, constant = ifelse(j=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID");
      data_vessel=merge(data_vessel, div_cats, all=T);
      setnames(data_vessel, "V1", paste("div_simpson_val", nomenclature[var==i, keys], nomenclature[var==j, keys], "year", sep="_"))
      }
    }


  
  
  


  
    for (i in c("ENGIN_COD",  "MAILLAGE", "DIMENSION", "SECT_COD_SACROIS_NIV3", "SECT_COD_SACROIS_NIV5", "SECT_COD_SACROIS_NIV6", "GRADIENT_COD", "ZEE_COD", "ESP2_COD_FAO", "SPP_COD_FAO", "FAMILY_COD_FAO", "ORDER_COD_FAO", "ISSCAAP_COD_FAO", "STOCK_ORGP")) {
          for (j in c("SEQ_ID", "QUANT_POIDS_VIF_SACROIS", "TP_NAVIRE_SACROIS")) {
      div_cats= div_index(SACROIS, "vessel_ID", i, abundance=j, constant = F, event="SEQ_ID", averaged = T, scale = "MAREE_ID");
      data_vessel=merge(data_vessel, div_cats, all=T, by.x="NAVS_COD_YEAR", by.y="vessel_ID");
      setnames(data_vessel, "V1", paste("div_simpson_val", nomenclature[var==i, keys], nomenclature[var==j, keys], "average_trip", sep="_"))
  }
}



  for (i in c("ENGIN_COD",  "MAILLAGE", "DIMENSION", "SECT_COD_SACROIS_NIV3", "SECT_COD_SACROIS_NIV5", "SECT_COD_SACROIS_NIV6", "GRADIENT_COD", "ZEE_COD", "ESP2_COD_FAO", "SPP_COD_FAO", "FAMILY_COD_FAO", "ORDER_COD_FAO", "ISSCAAP_COD_FAO", "STOCK_ORGP")) {
        for (j in c("SEQ_ID", "QUANT_POIDS_VIF_SACROIS", "TP_NAVIRE_SACROIS")) {
      div_cats= div_index(SACROIS, "vessel_ID", i, abundance=j, constant = F, event="SEQ_ID", averaged = T, scale = "MAREE_ID", SD=T);
      data_vessel=merge(data_vessel, div_cats, all=T, by.x="NAVS_COD_YEAR", by.y="vessel_ID");
      setnames(data_vessel, "V1", paste("div_simpson_val", nomenclature[var==i, keys], nomenclature[var==j, keys], "sde_trip", sep="_"))
        }
  }
  
      
      
      


  for (i in c("ESP2_COD_FAO", "SPP_COD_FAO", "FAMILY_COD_FAO", "ORDER_COD_FAO", "ISSCAAP_COD_FAO")) {
      div_cats= div_index(SACROIS, "NAVS_COD_YEAR", i, abundance="QUANT_POIDS_VIF_SACROIS", constant = F, event="SEQ_ID", averaged = T, scale = "SEQ_ID");
      data_vessel=merge(data_vessel, div_cats, all=T);
      setnames(data_vessel, "V1", paste("div_simpson_val", nomenclature[var==i, keys], "weight", "average_seq", sep="_"))
  }




  for (i in c("ESP2_COD_FAO", "SPP_COD_FAO", "FAMILY_COD_FAO", "ORDER_COD_FAO", "ISSCAAP_COD_FAO")) {
      div_cats= div_index(SACROIS, "NAVS_COD_YEAR", i, abundance="QUANT_POIDS_VIF_SACROIS", constant = F, event="SEQ_ID", averaged = T, scale = "SEQ_ID", SD=T);
      data_vessel=merge(data_vessel, div_cats, all=T);
      setnames(data_vessel, "V1", paste("div_simpson_val", nomenclature[var==i, keys], "weight", "sde_seq", sep="_"))
    }


  
  
  
  

  

  #on specific subset:
  

  

    for (i in c("SECT_COD_SACROIS_NIV3", "GRADIENT_COD2", "MONTH", "TRIMESTRE")) {
      for (j in c("ESP2_COD_FAO", "FAMILY_COD_FAO", "ENGIN_COD")) {
        if (i=="SECT_COD_SACROIS_NIV3") {
          for (k in c("27.8.a", "27.8.b")) {
                div_cats= div_index(SACROIS[eval(as.name(i))==k], "NAVS_COD_YEAR", j, abundance=ifelse(j=="ENGIN_COD", "TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS"), constant = ifelse(j=="ENGIN_COD", T, F), event="SEQ_ID");
                data_vessel=merge(data_vessel, div_cats, all=T);
                setnames(data_vessel, "V1", paste("DIV", toupper(nomenclature[var==i, keys]), "simpson", ifelse(j=="ENGIN_COD", "effort_fishing_time", "weight"), nomenclature[var==j, keys], k, sep="_"))
          }
        }
        else {
          for (k in unique(SACROIS$i)) {
                div_cats= div_index(SACROIS[eval(as.name(i))==k], "NAVS_COD_YEAR", j, abundance=ifelse(j=="ENGIN_COD", "TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS"), constant = ifelse(j=="ENGIN_COD", T, F), event="SEQ_ID");
                data_vessel=merge(data_vessel, div_cats, all=T);
                setnames(data_vessel, "V1", paste("DIV", toupper(nomenclature[var==i, keys]), "simpson", ifelse(j=="ENGIN_COD", "effort_fishing_time", "weight"), nomenclature[var==j, keys], k, sep="_"))
          }
        }
      }
    }




    for (i in c("MONTH", "TRIMESTRE")) {
      for (j in c("SECT_COD_SACROIS_NIV3", "SECT_COD_SACROIS_NIV5")) {
          for (k in unique(SACROIS$i)) {
                div_cats= div_index(SACROIS[eval(as.name(i))==k], "NAVS_COD_YEAR", j, abundance="TP_NAVIRE_SACROIS", constant = T, event="SEQ_ID");
                data_vessel=merge(data_vessel, div_cats, all=T);
                setnames(data_vessel, "V1", paste("DIV", toupper(nomenclature[var==i, keys]), "simpson", "effort_fishing_time", nomenclature[var==j, keys], k, sep="_"))
          }
      }
    }



  
  
  
  
  
  
  
  
  
  
  
  

### shannon



  for (i in c("ENGIN_COD",  "MAILLAGE", "DIMENSION", "SECT_COD_SACROIS_NIV3", "SECT_COD_SACROIS_NIV5", "SECT_COD_SACROIS_NIV6", "GRADIENT_COD", "ZEE_COD", "ESP2_COD_FAO", "SPP_COD_FAO", "FAMILY_COD_FAO", "ORDER_COD_FAO", "ISSCAAP_COD_FAO", "STOCK_ORGP")) {
    for (j in c("MAREE_ID", "SEQ_ID", "QUANT_POIDS_VIF_SACROIS", "TP_NAVIRE_SACROIS")) {
      div_cats= div_index(SACROIS, "NAVS_COD_YEAR", i, abundance=j, constant = ifelse(j=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID", method = "shannon");
      data_vessel=merge(data_vessel, div_cats, all=T);
      setnames(data_vessel, "V1", paste("div_shannon_val", nomenclature[var==i, keys], nomenclature[var==j, keys], "year", sep="_"))
      }
    }


  
  
  


  
    for (i in c("ENGIN_COD",  "MAILLAGE", "DIMENSION", "SECT_COD_SACROIS_NIV3", "SECT_COD_SACROIS_NIV5", "SECT_COD_SACROIS_NIV6", "GRADIENT_COD", "ZEE_COD", "ESP2_COD_FAO", "SPP_COD_FAO", "FAMILY_COD_FAO", "ORDER_COD_FAO", "ISSCAAP_COD_FAO", "STOCK_ORGP")) {
          for (j in c("SEQ_ID", "QUANT_POIDS_VIF_SACROIS", "TP_NAVIRE_SACROIS")) {
      div_cats= div_index(SACROIS, "vessel_ID", i, abundance=j, constant = F, event="SEQ_ID", averaged = T, scale = "MAREE_ID", method = "shannon");
      data_vessel=merge(data_vessel, div_cats, all=T, by.x="NAVS_COD_YEAR", by.y="vessel_ID");
      setnames(data_vessel, "V1", paste("div_shannon_val", nomenclature[var==i, keys], nomenclature[var==j, keys], "average_trip", sep="_"))
  }
}



  for (i in c("ENGIN_COD",  "MAILLAGE", "DIMENSION", "SECT_COD_SACROIS_NIV3", "SECT_COD_SACROIS_NIV5", "SECT_COD_SACROIS_NIV6", "GRADIENT_COD", "ZEE_COD", "ESP2_COD_FAO", "SPP_COD_FAO", "FAMILY_COD_FAO", "ORDER_COD_FAO", "ISSCAAP_COD_FAO", "STOCK_ORGP")) {
        for (j in c("SEQ_ID", "QUANT_POIDS_VIF_SACROIS", "TP_NAVIRE_SACROIS")) {
      div_cats= div_index(SACROIS, "vessel_ID", i, abundance=j, constant = F, event="SEQ_ID", averaged = T, scale = "MAREE_ID", SD=T, method = "shannon");
      data_vessel=merge(data_vessel, div_cats, all=T, by.x="NAVS_COD_YEAR", by.y="vessel_ID");
      setnames(data_vessel, "V1", paste("div_shannon_val", nomenclature[var==i, keys], nomenclature[var==j, keys], "sde_trip", sep="_"))
        }
  }
  
      
      
      


  for (i in c("ESP2_COD_FAO", "SPP_COD_FAO", "FAMILY_COD_FAO", "ORDER_COD_FAO", "ISSCAAP_COD_FAO")) {
      div_cats= div_index(SACROIS, "NAVS_COD_YEAR", i, abundance="QUANT_POIDS_VIF_SACROIS", constant = F, event="SEQ_ID", averaged = T, scale = "SEQ_ID", method = "shannon");
      data_vessel=merge(data_vessel, div_cats, all=T);
      setnames(data_vessel, "V1", paste("div_shannon_val", nomenclature[var==i, keys], "weight", "average_seq", sep="_"))
  }




  for (i in c("ESP2_COD_FAO", "SPP_COD_FAO", "FAMILY_COD_FAO", "ORDER_COD_FAO", "ISSCAAP_COD_FAO")) {
      div_cats= div_index(SACROIS, "NAVS_COD_YEAR", i, abundance="QUANT_POIDS_VIF_SACROIS", constant = F, event="SEQ_ID", averaged = T, scale = "SEQ_ID", SD=T, method = "shannon");
      data_vessel=merge(data_vessel, div_cats, all=T);
      setnames(data_vessel, "V1", paste("div_shannon_val", nomenclature[var==i, keys], "weight", "sde_seq", sep="_"))
    }










###### Main categories




  for (i in c("MONTH", "TRIMESTRE", "ENGIN_COD",  "MAILLAGE", "DIMENSION", "SECT_COD_SACROIS_NIV3", "SECT_COD_SACROIS_NIV5", "SECT_COD_SACROIS_NIV6", "GRADIENT_COD", "ZEE_COD", "ESP2_COD_FAO", "SPP_COD_FAO", "FAMILY_COD_FAO", "ORDER_COD_FAO", "ISSCAAP_COD_FAO", "STOCK_ORGP")) {
    for (j in c("SEQ_ID", "TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO")) { 
      main_cats= main_cat(SACROIS, "NAVS_COD_YEAR", i, j, ifelse(j=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID");
      data_vessel=merge(data_vessel, main_cats, all=T);
      setnames(data_vessel, i, paste("main", nomenclature[var==i, keys], nomenclature[var==j, keys], "year", sep="_"));
      setnames(data_vessel, "val", paste("main_value", nomenclature[var==i, keys], nomenclature[var==j, keys], "year", sep="_"));
      setnames(data_vessel, "prop", paste("main_prop", nomenclature[var==i, keys], nomenclature[var==j, keys], "year", sep="_"))
    }
  }  


  
  
  
  
  
  
  for (i in c("MONTH", "TRIMESTRE", "ENGIN_COD",  "MAILLAGE", "DIMENSION", "SECT_COD_SACROIS_NIV3", "SECT_COD_SACROIS_NIV5", "SECT_COD_SACROIS_NIV6", "GRADIENT_COD", "ZEE_COD", "ESP2_COD_FAO", "SPP_COD_FAO", "FAMILY_COD_FAO", "ORDER_COD_FAO", "ISSCAAP_COD_FAO", "STOCK_ORGP")) {
    for (j in c("TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO")) { 
      main_cats= main_cat(SACROIS, "vessel_ID", i, j, ifelse(j=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID", averaged=T, scale = "MAREE_ID");
      data_vessel=merge(data_vessel, main_cats, all=T, by.x="NAVS_COD_YEAR", by.y="vessel_ID");
      setnames(data_vessel, i, paste("main", nomenclature[var==i, keys], nomenclature[var==j, keys], "average_trip", sep="_"));
      setnames(data_vessel, "val", paste("main_value", nomenclature[var==i, keys], nomenclature[var==j, keys], "average_trip", sep="_"));
      setnames(data_vessel, "prop", paste("main_prop", nomenclature[var==i, keys], nomenclature[var==j, keys], "average_trip", sep="_"));
      setnames(data_vessel, "sd", paste("main_val", nomenclature[var==i, keys], nomenclature[var==j, keys], "sd_trip", sep="_"))
    }
  }  






  for (i in c("ESP2_COD_FAO", "SPP_COD_FAO", "FAMILY_COD_FAO", "ORDER_COD_FAO", "ISSCAAP_COD_FAO")) {
    for (j in c("QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS")) { 
      main_cats= main_cat(SACROIS, "vessel_ID", i, j, event="SEQ_ID", majority=T, scale = "MAREE_ID");
      data_vessel=merge(data_vessel, main_cats, all=T, by.x="NAVS_COD_YEAR", by.y="vessel_ID");
      setnames(data_vessel, i, paste("main", nomenclature[var==i, keys], nomenclature[var==j, keys], "majority_trip", sep="_"));
      setnames(data_vessel, "val", paste("main_value", nomenclature[var==i, keys], nomenclature[var==j, keys], "majority_trip", sep="_"));
      setnames(data_vessel, "prop", paste("main_prop", nomenclature[var==i, keys], nomenclature[var==j, keys], "majority_trip", sep="_"));
      setnames(data_vessel, "sd", paste("main_val_sd", nomenclature[var==i, keys], nomenclature[var==j, keys], "majority_trip", sep="_"));
      setnames(data_vessel, "sd_prop", paste("main_propor_sde", nomenclature[var==i, keys], nomenclature[var==j, keys], "majority_trip", sep="_"))
    }
  }  



  



  for (i in c("MONTH", "TRIMESTRE", "ENGIN_COD",  "MAILLAGE", "DIMENSION", "SECT_COD_SACROIS_NIV3", "SECT_COD_SACROIS_NIV5", "SECT_COD_SACROIS_NIV6", "GRADIENT_COD", "ZEE_COD", "ESP2_COD_FAO", "SPP_COD_FAO", "FAMILY_COD_FAO", "ORDER_COD_FAO", "ISSCAAP_COD_FAO", "STOCK_ORGP")) {
    for (j in c("TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO")) { 
      main_cats= main_cat(SACROIS, "NAVS_COD_YEAR", i, j, ifelse(j=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID", averaged=T, scale = "SEQ_ID");
      data_vessel=merge(data_vessel, main_cats, all=T);
      setnames(data_vessel, i, paste("main", nomenclature[var==i, keys], nomenclature[var==j, keys], "average_seq", sep="_"));
      setnames(data_vessel, "val", paste("main_value", nomenclature[var==i, keys], nomenclature[var==j, keys], "average_seq", sep="_"));
      setnames(data_vessel, "prop", paste("main_prop", nomenclature[var==i, keys], nomenclature[var==j, keys], "average_seq", sep="_"));
      setnames(data_vessel, "sd", paste("main_val", nomenclature[var==i, keys], nomenclature[var==j, keys], "sd_seq", sep="_"))
    }
  }  






  for (i in c("ESP2_COD_FAO", "SPP_COD_FAO", "FAMILY_COD_FAO", "ORDER_COD_FAO", "ISSCAAP_COD_FAO")) {
    for (j in c("QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS")) { 
      main_cats= main_cat(SACROIS, "NAVS_COD_YEAR", i, j, event="SEQ_ID", majority=T, scale = "SEQ_ID");
      data_vessel=merge(data_vessel, main_cats, all=T);
      setnames(data_vessel, i, paste("main", nomenclature[var==i, keys], nomenclature[var==j, keys], "majority_seq", sep="_"));
      setnames(data_vessel, "val", paste("main_value", nomenclature[var==i, keys], nomenclature[var==j, keys], "majority_seq", sep="_"));
      setnames(data_vessel, "prop", paste("main_prop", nomenclature[var==i, keys], nomenclature[var==j, keys], "majority_seq", sep="_"));
      setnames(data_vessel, "sd", paste("main_val_sd", nomenclature[var==i, keys], nomenclature[var==j, keys], "majority_seq", sep="_"));
      setnames(data_vessel, "sd_prop", paste("main_propor_sde", nomenclature[var==i, keys], nomenclature[var==j, keys], "majority_seq", sep="_"))
    }
  }  






#four subsequent blocks useful ? (computing mean/sd proportion/value only for main categories found by majority or average computation)

  
  
  for (i in c("MONTH", "TRIMESTRE", "ENGIN_COD",  "MAILLAGE", "DIMENSION", "SECT_COD_SACROIS_NIV3", "SECT_COD_SACROIS_NIV5", "SECT_COD_SACROIS_NIV6", "GRADIENT_COD", "ZEE_COD", "ESP2_COD_FAO", "SPP_COD_FAO", "FAMILY_COD_FAO", "ORDER_COD_FAO", "ISSCAAP_COD_FAO", "STOCK_ORGP")) {
    for (j in c("TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO")) { 
      main_cats= cat_prop_val(SACROIS, "vessel_ID", i, j, reference=data_vessel[,.(NAVS_COD_YEAR, eval(as.name(paste("main", nomenclature[var==i, keys], nomenclature[var==j, keys], "average_seq", sep="_"))))][,(i):=V2], constant=ifelse(j=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID", averaged=T, scale = "MAREE_ID");
      data_vessel=merge(data_vessel, main_cats[,.(NAVS_COD_YEAR, prop, sd_prop)], all=T, by.x="NAVS_COD_YEAR", by.y="vessel_ID");
      setnames(data_vessel, "prop", paste("main_true_prop", nomenclature[var==i, keys], nomenclature[var==j, keys], "average_trip", sep="_"));
      setnames(data_vessel, "sd_prop", paste("main_propor_sde", nomenclature[var==i, keys], nomenclature[var==j, keys], "average_trip", sep="_"))
    }
  }  




  for (i in c("ESP2_COD_FAO", "SPP_COD_FAO", "FAMILY_COD_FAO", "ORDER_COD_FAO", "ISSCAAP_COD_FAO")) {
    for (j in c("QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS")) { 
      main_cats= cat_prop_val(SACROIS, "vessel_ID", i, j, reference=data_vessel[,.(NAVS_COD_YEAR, eval(as.name(paste("main", nomenclature[var==i, keys], nomenclature[var==j, keys], "majority_seq", sep="_"))))][,(i):=V2], constant=ifelse(j=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID", averaged=T, scale = "MAREE_ID");
      data_vessel=merge(data_vessel, main_cats, all=T, by.x="NAVS_COD_YEAR", by.y="vessel_ID");
      setnames(data_vessel, "val", paste("main_true_value", nomenclature[var==i, keys], nomenclature[var==j, keys], "majority_trip", sep="_"));
      setnames(data_vessel, "prop", paste("main_true_prop", nomenclature[var==i, keys], nomenclature[var==j, keys], "majority_trip", sep="_"));
      setnames(data_vessel, "sd", paste("main_true_val_sd", nomenclature[var==i, keys], nomenclature[var==j, keys], "majority_trip", sep="_"));
      setnames(data_vessel, "sd_prop", paste("main_true_propor_sde", nomenclature[var==i, keys], nomenclature[var==j, keys], "majority_trip", sep="_"))
    }
  }  

  
  
  
  
  for (i in c("MONTH", "TRIMESTRE", "ENGIN_COD",  "MAILLAGE", "DIMENSION", "SECT_COD_SACROIS_NIV3", "SECT_COD_SACROIS_NIV5", "SECT_COD_SACROIS_NIV6", "GRADIENT_COD", "ZEE_COD", "ESP2_COD_FAO", "SPP_COD_FAO", "FAMILY_COD_FAO", "ORDER_COD_FAO", "ISSCAAP_COD_FAO", "STOCK_ORGP")) {
    for (j in c("TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO")) { 
      main_cats= cat_prop_val(SACROIS, "NAVS_COD_YEAR", i, j, reference=data_vessel[,.(NAVS_COD_YEAR, eval(as.name(paste("main", nomenclature[var==i, keys], nomenclature[var==j, keys], "average_seq", sep="_"))))][,(i):=V2], constant=ifelse(j=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID", averaged=T, scale = "SEQ_ID");
      data_vessel=merge(data_vessel, main_cats[,.(NAVS_COD_YEAR, prop, sd_prop)], all=T);
      setnames(data_vessel, "prop", paste("main_true_prop", nomenclature[var==i, keys], nomenclature[var==j, keys], "average_seq", sep="_"));
      setnames(data_vessel, "sd_prop", paste("main_propor_sde", nomenclature[var==i, keys], nomenclature[var==j, keys], "average_seq", sep="_"))
    }
  }  




  for (i in c("ESP2_COD_FAO", "SPP_COD_FAO", "FAMILY_COD_FAO", "ORDER_COD_FAO", "ISSCAAP_COD_FAO")) {
    for (j in c("QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS")) { 
      main_cats= cat_prop_val(SACROIS, "NAVS_COD_YEAR", i, j, reference=data_vessel[,.(NAVS_COD_YEAR, eval(as.name(paste("main", nomenclature[var==i, keys], nomenclature[var==j, keys], "majority_seq", sep="_"))))][,(i):=V2], constant=ifelse(j=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID", averaged=T, scale = "SEQ_ID");
      data_vessel=merge(data_vessel, main_cats, all=T);
      setnames(data_vessel, "val", paste("main_true_value", nomenclature[var==i, keys], nomenclature[var==j, keys], "majority_seq", sep="_"));
      setnames(data_vessel, "prop", paste("main_true_prop", nomenclature[var==i, keys], nomenclature[var==j, keys], "majority_seq", sep="_"));
      setnames(data_vessel, "sd", paste("main_true_val_sd", nomenclature[var==i, keys], nomenclature[var==j, keys], "majority_seq", sep="_"));
      setnames(data_vessel, "sd_prop", paste("main_true_propor_sde", nomenclature[var==i, keys], nomenclature[var==j, keys], "majority_seq", sep="_"))
    }
  }  




  
  
  #on specific subset:
  

  

    for (i in c("SECT_COD_SACROIS_NIV3", "GRADIENT_COD2", "MONTH", "TRIMESTRE")) {
      for (j in c("ESP2_COD_FAO", "FAMILY_COD_FAO", "ENGIN_COD")) {
        if (i=="SECT_COD_SACROIS_NIV3") {
          for (k in c("27.8.a", "27.8.b")) {
                main_cats= main_cat(SACROIS[eval(as.name(i))==k], "NAVS_COD_YEAR", j, abundance="QUANT_POIDS_VIF_SACROIS", constant = F, event="SEQ_ID");
                data_vessel=merge(data_vessel, main_cats, all=T);
                setnames(data_vessel, "V1", paste("MAIN", toupper(nomenclature[var==i, keys]), nomenclature[var==j, keys], "weight", k, sep="_"))
          }
        }
        else {
          for (k in unique(SACROIS$i)) {
                main_cats= main_cat(SACROIS[eval(as.name(i))==k], "NAVS_COD_YEAR", j, abundance="QUANT_POIDS_VIF_SACROIS", constant = F, event="SEQ_ID");
                data_vessel=merge(data_vessel, main_cats, all=T);
                setnames(data_vessel, "V1", paste("MAIN", toupper(nomenclature[var==i, keys]), nomenclature[var==j, keys], "weight", k, sep="_"))
          }
        }
      }
    }




    for (i in c("MONTH", "TRIMESTRE")) {
      for (j in c("SECT_COD_SACROIS_NIV3", "SECT_COD_SACROIS_NIV5")) {
          for (k in unique(SACROIS$i)) {
                main_cats= main_cat(SACROIS[eval(as.name(i))==k], "NAVS_COD_YEAR", j, abundance="QUANT_POIDS_VIF_SACROIS", constant = F, event="SEQ_ID");
                data_vessel=merge(data_vessel, main_cats, all=T);
                setnames(data_vessel, "V1", paste("MAIN", toupper(nomenclature[var==i, keys]), nomenclature[var==j, keys], "weight", k, sep="_"))
          }
      }
    }


  
  
  
  
  
  
  
  
  
  
  
  
  





###### proportion and values of categories frequently associated with each others:





### Species



basket=tapply(SACROIS$ESP2_COD_FAO, SACROIS$NAVS_COD_YEAR, unique, simplify = FALSE) #WARNING: to be runned only for the subset of interest (way too heavy otherwise !!!!)

names(basket)=NULL

basket=list(basket)

basket=unlist(basket, recursive = F)

names(basket)=names(tapply(SACROIS$ESP2_COD_FAO, SACROIS$NAVS_COD_YEAR, unique, simplify = FALSE))

#creation of a "basket" of species (all species captured at least once for each vessels)



trans <- as(basket, "transactions") #transaction class for association rule modelling


rules_chi2 <- apriori(trans, parameter = list(supp = 0.1, conf = 0.8,minlen=2,maxlen=2, arem = "chi2"))

#secondary selection of selection statistically supported by chi-squared tests
#support: probability threshold of the combination on the whole dataset => set on default parameter
#conf: probability threshold for the association (A knowing B)  => set on default parameter


target_species=union(as.vector(unique(inspect(rules_chi2)$lhs)),as.vector(unique(inspect(rules_chi2)$rhs)))
#all species implied in a relevant association


target_species= str_extract(target_species, pattern="(?<=\\{)(.*)(?=\\})" )





remove(list=c("basket", "rules_chi2","trans")) # removes elements without any more use, to avoid memory overload
gc()






  for (i in target_species) {
    for (j in c("SEQ_ID", "TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO")) { 
      main_cats= cat_prop_val(SACROIS, "NAVS_COD_YEAR", "ESP2_COD_FAO", j, reference=i, constant=ifelse(j=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID", averaged=F);
      data_vessel=merge(data_vessel, main_cats, all=T);
      setnames(data_vessel, "val", paste("SPE", nomenclature[var==j, keys], i, sep="_"));
      setnames(data_vessel, "prop", paste("SPE_prop", nomenclature[var==j, keys], i, sep="_"))
    }
  } 




  for (i in target_species) {
    for (j in c("SEQ_ID", "TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO")) { 
      main_cats= cat_prop_val(SACROIS, "NAVS_COD_YEAR", "ESP2_COD_FAO", j, reference=i, constant=ifelse(j=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID", averaged=T, scale = "SEQ_ID");
      data_vessel=merge(data_vessel, main_cats, all=T);
      setnames(data_vessel, "val", paste("SPE", nomenclature[var==j, keys], i, "average_seq", sep="_"));
      setnames(data_vessel, "prop", paste("SPE_prop", nomenclature[var==j, keys], i, "average_seq", sep="_"))
    }
  } 







### Group of species





basket=tapply(SACROIS$SPP_COD_FAO, SACROIS$NAVS_COD_YEAR, unique, simplify = FALSE) #WARNING: to be runned only for the subset of interest (way too heavy otherwise !!!!)

names(basket)=NULL

basket=list(basket)

basket=unlist(basket, recursive = F)

names(basket)=names(tapply(SACROIS$SPP_COD_FAO, SACROIS$NAVS_COD_YEAR, unique, simplify = FALSE))

#creation of a "basket" of species (all species captured at least once for each vessels)



trans <- as(basket, "transactions") #transaction class for association rule modelling


rules_chi2 <- apriori(trans, parameter = list(supp = 0.1, conf = 0.8,minlen=2,maxlen=2, arem = "chi2"))

#secondary selection of selection statistically supported by chi-squared tests
#support: probability threshold of the combination on the whole dataset => set on default parameter
#conf: probability threshold for the association (A knowing B)  => set on default parameter


target_spp=union(as.vector(unique(inspect(rules_chi2)$lhs)),as.vector(unique(inspect(rules_chi2)$rhs)))
#all species implied in a relevant association


target_spp= str_extract(target_spp, pattern="(?<=\\{)(.*)(?=\\})" )





remove(list=c("basket", "rules_chi2","trans")) # removes elements without any more use, to avoid memory overload
gc()






  for (i in target_spp) {
    for (j in c("SEQ_ID", "TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO")) { 
      main_cats= cat_prop_val(SACROIS, "NAVS_COD_YEAR", "SPP_COD_FAO", j, reference=i, constant=ifelse(j=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID", averaged=F);
      data_vessel=merge(data_vessel, main_cats, all=T);
      setnames(data_vessel, "val", paste("SPP", nomenclature[var==j, keys], i, sep="_"));
      setnames(data_vessel, "prop", paste("SPP_prop", nomenclature[var==j, keys], i, sep="_"))
    }
  } 




  for (i in target_spp) {
    for (j in c("SEQ_ID", "TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO")) { 
      main_cats= cat_prop_val(SACROIS, "NAVS_COD_YEAR", "SPP_COD_FAO", j, reference=i, constant=ifelse(j=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID", averaged=T, scale = "SEQ_ID");
      data_vessel=merge(data_vessel, main_cats, all=T);
      setnames(data_vessel, "val", paste("SPP", nomenclature[var==j, keys], i, "average_seq", sep="_"));
      setnames(data_vessel, "prop", paste("SPP_prop", nomenclature[var==j, keys], i, "average_seq", sep="_"))
    }
  } 









### Family








basket=tapply(SACROIS$FAMILY_COD_FAO, SACROIS$NAVS_COD_YEAR, unique, simplify = FALSE) #WARNING: to be runned only for the subset of interest (way too heavy otherwise !!!!)

names(basket)=NULL

basket=list(basket)

basket=unlist(basket, recursive = F)

names(basket)=names(tapply(SACROIS$FAMILY_COD_FAO, SACROIS$NAVS_COD_YEAR, unique, simplify = FALSE))

#creation of a "basket" of species (all species captured at least once for each vessels)



trans <- as(basket, "transactions") #transaction class for association rule modelling


rules_chi2 <- apriori(trans, parameter = list(supp = 0.1, conf = 0.8,minlen=2,maxlen=2, arem = "chi2"))

#secondary selection of selection statistically supported by chi-squared tests
#support: probability threshold of the combination on the whole dataset => set on default parameter
#conf: probability threshold for the association (A knowing B)  => set on default parameter


target_family=union(as.vector(unique(inspect(rules_chi2)$lhs)),as.vector(unique(inspect(rules_chi2)$rhs)))
#all species implied in a relevant association


target_family= str_extract(target_family, pattern="(?<=\\{)(.*)(?=\\})" )





remove(list=c("basket", "rules_chi2","trans")) # removes elements without any more use, to avoid memory overload
gc()






  for (i in target_family) {
    for (j in c("SEQ_ID", "TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO")) { 
      main_cats= cat_prop_val(SACROIS, "NAVS_COD_YEAR", "FAMILY_COD_FAO", j, reference=i, constant=ifelse(j=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID", averaged=F);
      data_vessel=merge(data_vessel, main_cats, all=T);
      setnames(data_vessel, "val", paste("FAMILY", nomenclature[var==j, keys], i, sep="_"));
      setnames(data_vessel, "prop", paste("FAMILY_prop", nomenclature[var==j, keys], i, sep="_"))
    }
  } 




  for (i in target_family) {
    for (j in c("SEQ_ID", "TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO")) { 
      main_cats= cat_prop_val(SACROIS, "NAVS_COD_YEAR", "FAMILY_COD_FAO", j, reference=i, constant=ifelse(j=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID", averaged=T, scale = "SEQ_ID");
      data_vessel=merge(data_vessel, main_cats, all=T);
      setnames(data_vessel, "val", paste("FAMILY", nomenclature[var==j, keys], i, "average_seq", sep="_"));
      setnames(data_vessel, "prop", paste("FAMILY_prop", nomenclature[var==j, keys], i, "average_seq", sep="_"))
    }
  } 











### Order








basket=tapply(SACROIS$ORDER_COD_FAO, SACROIS$NAVS_COD_YEAR, unique, simplify = FALSE) #WARNING: to be runned only for the subset of interest (way too heavy otherwise !!!!)

names(basket)=NULL

basket=list(basket)

basket=unlist(basket, recursive = F)

names(basket)=names(tapply(SACROIS$ORDER_COD_FAO, SACROIS$NAVS_COD_YEAR, unique, simplify = FALSE))

#creation of a "basket" of species (all species captured at least once for each vessels)



trans <- as(basket, "transactions") #transaction class for association rule modelling


rules_chi2 <- apriori(trans, parameter = list(supp = 0.1, conf = 0.8,minlen=2,maxlen=2, arem = "chi2"))

#secondary selection of selection statistically supported by chi-squared tests
#support: probability threshold of the combination on the whole dataset => set on default parameter
#conf: probability threshold for the association (A knowing B)  => set on default parameter


target_order=union(as.vector(unique(inspect(rules_chi2)$lhs)),as.vector(unique(inspect(rules_chi2)$rhs)))
#all species implied in a relevant association


target_order= str_extract(target_order, pattern="(?<=\\{)(.*)(?=\\})" )





remove(list=c("basket", "rules_chi2","trans")) # removes elements without any more use, to avoid memory overload
gc()






  for (i in target_order) {
    for (j in c("SEQ_ID", "TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO")) { 
      main_cats= cat_prop_val(SACROIS, "NAVS_COD_YEAR", "ORDER_COD_FAO", j, reference=i, constant=ifelse(j=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID", averaged=F);
      data_vessel=merge(data_vessel, main_cats, all=T);
      setnames(data_vessel, "val", paste("ORDER", nomenclature[var==j, keys], i, sep="_"));
      setnames(data_vessel, "prop", paste("ORDER_prop", nomenclature[var==j, keys], i, sep="_"))
    }
  } 




  for (i in target_order) {
    for (j in c("SEQ_ID", "TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO")) { 
      main_cats= cat_prop_val(SACROIS, "NAVS_COD_YEAR", "ORDER_COD_FAO", j, reference=i, constant=ifelse(j=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID", averaged=T, scale = "SEQ_ID");
      data_vessel=merge(data_vessel, main_cats, all=T);
      setnames(data_vessel, "val", paste("ORDER", nomenclature[var==j, keys], i, "average_seq", sep="_"));
      setnames(data_vessel, "prop", paste("ORDER_prop", nomenclature[var==j, keys], i, "average_seq", sep="_"))
    }
  } 











### ISSCAAP








basket=tapply(SACROIS$ISSCAAP_COD_FAO, SACROIS$NAVS_COD_YEAR, unique, simplify = FALSE) #WARNING: to be runned only for the subset of interest (way too heavy otherwise !!!!)

names(basket)=NULL

basket=list(basket)

basket=unlist(basket, recursive = F)

names(basket)=names(tapply(SACROIS$ISSCAAP_COD_FAO, SACROIS$NAVS_COD_YEAR, unique, simplify = FALSE))

#creation of a "basket" of species (all species captured at least once for each vessels)



trans <- as(basket, "transactions") #transaction class for association rule modelling


rules_chi2 <- apriori(trans, parameter = list(supp = 0.1, conf = 0.8,minlen=2,maxlen=2, arem = "chi2"))

#secondary selection of selection statistically supported by chi-squared tests
#support: probability threshold of the combination on the whole dataset => set on default parameter
#conf: probability threshold for the association (A knowing B)  => set on default parameter


target_isscaap=union(as.vector(unique(inspect(rules_chi2)$lhs)),as.vector(unique(inspect(rules_chi2)$rhs)))
#all species implied in a relevant association


target_isscaap= str_extract(target_isscaap, pattern="(?<=\\{)(.*)(?=\\})" )





remove(list=c("basket", "rules_chi2","trans")) # removes elements without any more use, to avoid memory overload
gc()






  for (i in target_isscaap) {
    for (j in c("SEQ_ID", "TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO")) { 
      main_cats= cat_prop_val(SACROIS, "NAVS_COD_YEAR", "ISSCAAP_COD_FAO", j, reference=i, constant=ifelse(j=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID", averaged=F);
      data_vessel=merge(data_vessel, main_cats, all=T);
      setnames(data_vessel, "val", paste("ISSCAAP", nomenclature[var==j, keys], i, sep="_"));
      setnames(data_vessel, "prop", paste("ISSCAAP_prop", nomenclature[var==j, keys], i, sep="_"))
    }
  } 




  for (i in target_isscaap) {
    for (j in c("SEQ_ID", "TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO")) { 
      main_cats= cat_prop_val(SACROIS, "NAVS_COD_YEAR", "ISSCAAP_COD_FAO", j, reference=i, constant=ifelse(j=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID", averaged=T, scale = "SEQ_ID");
      data_vessel=merge(data_vessel, main_cats, all=T);
      setnames(data_vessel, "val", paste("ISSCAAP", nomenclature[var==j, keys], i, "average_seq", sep="_"));
      setnames(data_vessel, "prop", paste("ISSCAAP_prop", nomenclature[var==j, keys], i, "average_seq", sep="_"))
    }
  } 







###ICES division:





  for (i in c("27.8.a", "27.8.b")) {
    for (j in c("SEQ_ID", "TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO")) { 
      main_cats= cat_prop_val(SACROIS, "NAVS_COD_YEAR", "SECT_COD_SACROIS_NIV3", j, reference=i, constant=ifelse(j=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID", averaged=F);
      data_vessel=merge(data_vessel, main_cats, all=T);
      setnames(data_vessel, "val", paste("ICES_DIVIS", nomenclature[var==j, keys], i, sep="_"));
      setnames(data_vessel, "prop", paste("ICES_DIVIS_prop", nomenclature[var==j, keys], i, sep="_"))
    }
  } 




  for (i in c("27.8.a", "27.8.b")) {
    for (j in c("SEQ_ID", "TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO")) { 
      main_cats= cat_prop_val(SACROIS, "NAVS_COD_YEAR", "SECT_COD_SACROIS_NIV3", j, reference=i, constant=ifelse(j=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID", averaged=T, scale = "SEQ_ID");
      data_vessel=merge(data_vessel, main_cats, all=T);
      setnames(data_vessel, "val", paste("ICES_DIVIS", nomenclature[var==j, keys], i, "average_seq", sep="_"));
      setnames(data_vessel, "prop", paste("ICES_DIVIS_prop", nomenclature[var==j, keys], i, "average_seq", sep="_"))
    }
  } 













###Gradient:





  for (i in unique(SACROIS$GRADIENT_COD2)) {
    for (j in c("SEQ_ID", "TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO")) { 
      main_cats= cat_prop_val(SACROIS, "NAVS_COD_YEAR", "GRADIENT_COD2", j, reference=i, constant=ifelse(j=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID", averaged=F);
      data_vessel=merge(data_vessel, main_cats, all=T);
      setnames(data_vessel, "val", paste("GRADIENT", nomenclature[var==j, keys], i, sep="_"));
      setnames(data_vessel, "prop", paste("GRADIENT_prop", nomenclature[var==j, keys], i, sep="_"))
    }
  } 




  for (i in unique(SACROIS$GRADIENT_COD2)) {
    for (j in c("SEQ_ID", "TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO")) { 
      main_cats= cat_prop_val(SACROIS, "NAVS_COD_YEAR", "GRADIENT_COD2", j, reference=i, constant=ifelse(j=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID", averaged=T, scale = "SEQ_ID");
      data_vessel=merge(data_vessel, main_cats, all=T);
      setnames(data_vessel, "val", paste("GRADIENT", nomenclature[var==j, keys], i, "average_seq", sep="_"));
      setnames(data_vessel, "prop", paste("GRADIENT_prop", nomenclature[var==j, keys], i, "average_seq", sep="_"))
    }
  } 














###Month:





  for (i in unique(SACROIS$MONTH)) {
    for (j in c("SEQ_ID", "TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO")) { 
      main_cats= cat_prop_val(SACROIS, "NAVS_COD_YEAR", "MONTH", j, reference=i, constant=ifelse(j=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID", averaged=F);
      data_vessel=merge(data_vessel, main_cats, all=T);
      setnames(data_vessel, "val", paste("MONTH", nomenclature[var==j, keys], i, sep="_"));
      setnames(data_vessel, "prop", paste("MONTH_prop", nomenclature[var==j, keys], i, sep="_"))
    }
  } 




  for (i in unique(SACROIS$MONTH)) {
    for (j in c("SEQ_ID", "TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO")) { 
      main_cats= cat_prop_val(SACROIS, "NAVS_COD_YEAR", "MONTH", j, reference=i, constant=ifelse(j=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID", averaged=T, scale = "SEQ_ID");
      data_vessel=merge(data_vessel, main_cats, all=T);
      setnames(data_vessel, "val", paste("MONTH", nomenclature[var==j, keys], i, "average_seq", sep="_"));
      setnames(data_vessel, "prop", paste("MONTH_prop", nomenclature[var==j, keys], i, "average_seq", sep="_"))
    }
  } 














###Trimester:





  for (i in unique(SACROIS$TRIMESTRE)) {
    for (j in c("SEQ_ID", "TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO")) { 
      main_cats= cat_prop_val(SACROIS, "NAVS_COD_YEAR", "TRIMESTRE", j, reference=i, constant=ifelse(j=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID", averaged=F);
      data_vessel=merge(data_vessel, main_cats, all=T);
      setnames(data_vessel, "val", paste("TRIMESTER", nomenclature[var==j, keys], i, sep="_"));
      setnames(data_vessel, "prop", paste("TRIMESTER_prop", nomenclature[var==j, keys], i, sep="_"))
    }
  } 




  for (i in unique(SACROIS$TRIMESTRE)) {
    for (j in c("SEQ_ID", "TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO")) { 
      main_cats= cat_prop_val(SACROIS, "NAVS_COD_YEAR", "TRIMESTRE", j, reference=i, constant=ifelse(j=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID", averaged=T, scale = "SEQ_ID");
      data_vessel=merge(data_vessel, main_cats, all=T);
      setnames(data_vessel, "val", paste("TRIMESTER", nomenclature[var==j, keys], i, "average_seq", sep="_"));
      setnames(data_vessel, "prop", paste("TRIMESTER_prop", nomenclature[var==j, keys], i, "average_seq", sep="_"))
    }
  } 










###### Secondary categories of importance 





  for (i in c("ESP2_COD_FAO", "SPP_COD_FAO", "FAMILY_COD_FAO", "ORDER_COD_FAO", "ISSCAAP_COD_FAO", "ENGIN_COD")) {
    for (j in c("SEQ_ID", "TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO")) { 
      second_cats= secondary_cat(SACROIS, "NAVS_COD_YEAR", i, j, first=data_vessel[,.(NAVS_COD_YEAR, eval(as.name(paste("main", nomenclature[var==i, keys], nomenclature[var==j, keys], "trip", sep="_"))))][,(i):=V2], constant=ifelse(j=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID");
      data_vessel=merge(data_vessel, second_cats, all=T);
      setnames(data_vessel, i, paste("second", nomenclature[var==i, keys], nomenclature[var==j, keys], sep="_"));
      setnames(data_vessel, "val", paste("second_value", nomenclature[var==i, keys], nomenclature[var==j, keys], sep="_"));
      setnames(data_vessel, "prop", paste("second_prop", nomenclature[var==i, keys], nomenclature[var==j, keys], sep="_"))
    }
  } 



  for (i in c("ESP2_COD_FAO", "SPP_COD_FAO", "FAMILY_COD_FAO", "ORDER_COD_FAO", "ISSCAAP_COD_FAO")) {
    for (j in c("SEQ_ID", "TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO")) { 
      third_cats= secondary_cat(SACROIS, "NAVS_COD_YEAR", i, j, first=data_vessel[,.(NAVS_COD_YEAR, eval(as.name(paste("main", nomenclature[var==i, keys], nomenclature[var==j, keys], "trip", sep="_"))))][,(i):=V2], second=data_vessel[,.(NAVS_COD_YEAR, eval(as.name(paste("second", nomenclature[var==i, keys], nomenclature[var==j, keys], sep="_"))))][,(i):=V2], constant=ifelse(j=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID");
      data_vessel=merge(data_vessel, third_cats, all=T);
      setnames(data_vessel, i, paste("third", nomenclature[var==i, keys], nomenclature[var==j, keys], sep="_"));
      setnames(data_vessel, "val", paste("third_value", nomenclature[var==i, keys], nomenclature[var==j, keys], sep="_"));
      setnames(data_vessel, "prop", paste("third_prop", nomenclature[var==i, keys], nomenclature[var==j, keys], sep="_"))
    }
  } 










###### Quantitative value



SACROIS[,MAILLAGE:=as.numeric(MAILLAGE)]




  for (i in c("TP_NAVIRE_SACROIS", "TPS_MER", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO")) {
    quantity= quant_values(SACROIS, "NAVS_COD_YEAR", i, constant=ifelse(i=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID");
    data_vessel=merge(data_vessel, quantity, all=T);
    setnames(data_vessel, "V1", paste("value", nomenclature[var==i, keys], "year", sep="_"))
  }






  for (i in c("TP_NAVIRE_SACROIS", "TPS_MER", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO", "MAILLAGE", "DATE_SEQ_DAY", "MONTH", "TRIMESTRE")) {
    quantity= quant_values(SACROIS, "vessel_ID", i, constant=ifelse(i %in% c("TP_NAVIRE_SACROIS", "MAILLAGE", "DATE_SEQ_DAY", "MONTH", "TRIMESTRE"), T, F), event="SEQ_ID", averaged = T, scale = "MAREE_ID");
    data_vessel=merge(data_vessel, quantity, all=T, by.x="NAVS_COD_YEAR", by.y="vessel_ID");
    setnames(data_vessel, "V1", paste("value", nomenclature[var==i, keys], "average_trip", sep="_"))
  }  




  for (i in c("TP_NAVIRE_SACROIS", "TPS_MER", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO", "MAILLAGE", "DATE_SEQ_DAY", "MONTH", "TRIMESTRE")) {
    quantity= quant_values(SACROIS, "vessel_ID", i, constant=ifelse(i %in% c("TP_NAVIRE_SACROIS", "MAILLAGE", "DATE_SEQ_DAY", "MONTH", "TRIMESTRE"), T, F), event="SEQ_ID", averaged = T, scale = "MAREE_ID", SD=T);
    data_vessel=merge(data_vessel, quantity, all=T, by.x="NAVS_COD_YEAR", by.y="vessel_ID");
    setnames(data_vessel, "V1", paste("sd", nomenclature[var==i, keys], "average_trip", sep="_"))
  }  





  for (i in c("TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO", "MAILLAGE", "DATE_SEQ_DAY", "MONTH", "TRIMESTRE")) {
    quantity= quant_values(SACROIS, "NAVS_COD_YEAR", i, constant=ifelse(i %in% c("TP_NAVIRE_SACROIS", "MAILLAGE", "DATE_SEQ_DAY", "MONTH", "TRIMESTRE"), T, F), event="SEQ_ID", averaged = T, scale = "SEQ_ID");
    data_vessel=merge(data_vessel, quantity, all=T);
    setnames(data_vessel, "V1", paste("value", nomenclature[var==i, keys], "average_seq", sep="_"))
  }  




  for (i in c("TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO", "MAILLAGE", "DATE_SEQ_DAY", "MONTH", "TRIMESTRE")) {
    quantity= quant_values(SACROIS, "NAVS_COD_YEAR", i, constant=ifelse(i %in% c("TP_NAVIRE_SACROIS", "MAILLAGE", "DATE_SEQ_DAY", "MONTH", "TRIMESTRE"), T, F), event="SEQ_ID", averaged = T, scale = "SEQ_ID", SD=T);
    data_vessel=merge(data_vessel, quantity, all=T);
    setnames(data_vessel, "V1", paste("sd", nomenclature[var==i, keys], "average_seq", sep="_"))
  }  









  for (i in c("TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO")) {
    for (j in c("ESP2_COD_FAO", "SPP_COD_FAO", "FAMILY_COD_FAO", "ORDER_COD_FAO", "ISSCAAP_COD_FAO","STOCK_ORGP", "ENGIN_COD")) {
      quantity= quant_values(SACROIS, "NAVS_COD_YEAR", i, constant=ifelse(i=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID", averaged = T, scale = j);
      data_vessel=merge(data_vessel, quantity, all=T);
      setnames(data_vessel, "V1", paste("value", nomenclature[var==i, keys], "mean", nomenclature[var==j, keys], sep="_"))
    }  
  }  





  for (i in c("TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO")) {
    for (j in c("ESP2_COD_FAO", "SPP_COD_FAO", "FAMILY_COD_FAO", "ORDER_COD_FAO", "ISSCAAP_COD_FAO","STOCK_ORGP", "ENGIN_COD")) {
      quantity= quant_values(SACROIS, "NAVS_COD_YEAR", i, constant=ifelse(i=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID", averaged = T, scale = j, SD=T);
      data_vessel=merge(data_vessel, quantity, all=T);
      setnames(data_vessel, "V1", paste("sd", nomenclature[var==i, keys], "mean", nomenclature[var==j, keys], sep="_"))
    }  
  }  




















  for (i in c("TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO")) {
    for (j in c("ESP2_COD_FAO", "SPP_COD_FAO", "FAMILY_COD_FAO", "ORDER_COD_FAO", "ISSCAAP_COD_FAO","STOCK_ORGP", "ENGIN_COD")) {
      quantity= quant_values(SACROIS, "vessel_ID", i, constant=ifelse(i=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID", averaged = T, scale = "MAREE_ID", averaged2 = T, scale2=j);
      data_vessel=merge(data_vessel, quantity, all=T, by.x="NAVS_COD_YEAR", by.y="vessel_ID");
      setnames(data_vessel, "V1", paste("value", nomenclature[var==i, keys], "mean", nomenclature[var==j, keys], "average_trip", sep="_"))
    }  
  }  





  for (i in c("TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO")) {
    for (j in c("ESP2_COD_FAO", "SPP_COD_FAO", "FAMILY_COD_FAO", "ORDER_COD_FAO", "ISSCAAP_COD_FAO","STOCK_ORGP", "ENGIN_COD")) {
      quantity= quant_values(SACROIS, "vessel_ID", i, constant=ifelse(i=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID", averaged = T, scale = "MAREE_ID", averaged2 = T, scale2=j, SD=T);
      data_vessel=merge(data_vessel, quantity, all=T, by.x="NAVS_COD_YEAR", by.y="vessel_ID");
      setnames(data_vessel, "V1", paste("sd", nomenclature[var==i, keys], "mean", nomenclature[var==j, keys], "average_trip", sep="_"))
    }  
  }  



  for (i in c("TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO")) {
    for (j in c("ESP2_COD_FAO", "SPP_COD_FAO", "FAMILY_COD_FAO", "ORDER_COD_FAO", "ISSCAAP_COD_FAO","STOCK_ORGP", "ENGIN_COD")) {
      quantity= quant_values(SACROIS, "vessel_ID", i, constant=ifelse(i=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID", averaged = T, scale = "MAREE_ID", averaged2 = T, scale2=j, SD2=T);
      data_vessel=merge(data_vessel, quantity, all=T, by.x="NAVS_COD_YEAR", by.y="vessel_ID");
      setnames(data_vessel, "V1", paste("val", nomenclature[var==i, keys], "sd", nomenclature[var==j, keys], "average_trip", sep="_"))
    }  
  }  



  for (i in c("TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO")) {
    for (j in c("ESP2_COD_FAO", "SPP_COD_FAO", "FAMILY_COD_FAO", "ORDER_COD_FAO", "ISSCAAP_COD_FAO","STOCK_ORGP", "ENGIN_COD")) {
      quantity= quant_values(SACROIS, "vessel_ID", i, constant=ifelse(i=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID", averaged = T, scale = "MAREE_ID", averaged2 = T, scale2=j, SD=T, SD2=T);
      data_vessel=merge(data_vessel, quantity, all=T, by.x="NAVS_COD_YEAR", by.y="vessel_ID");
      setnames(data_vessel, "V1", paste("sd", nomenclature[var==i, keys], "sd", nomenclature[var==j, keys], "average_trip", sep="_"))
    }  
  }  


















  for (i in c("TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO")) {
    for (j in c("ESP2_COD_FAO", "SPP_COD_FAO", "FAMILY_COD_FAO", "ORDER_COD_FAO", "ISSCAAP_COD_FAO","STOCK_ORGP", "ENGIN_COD")) {
      quantity= quant_values(SACROIS, "NAVS_COD_YEAR", i, constant=ifelse(i=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID", averaged = T, scale = "SEQ_ID", averaged2 = T, scale2=j);
      data_vessel=merge(data_vessel, quantity, all=T);
      setnames(data_vessel, "V1", paste("value", nomenclature[var==i, keys], "mean", nomenclature[var==j, keys], "average_seq", sep="_"))
    }  
  }  





  for (i in c("TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO")) {
    for (j in c("ESP2_COD_FAO", "SPP_COD_FAO", "FAMILY_COD_FAO", "ORDER_COD_FAO", "ISSCAAP_COD_FAO","STOCK_ORGP", "ENGIN_COD")) {
      quantity= quant_values(SACROIS, "NAVS_COD_YEAR", i, constant=ifelse(i=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID", averaged = T, scale = "SEQ_ID", averaged2 = T, scale2=j, SD=T);
      data_vessel=merge(data_vessel, quantity, all=T);
      setnames(data_vessel, "V1", paste("sd", nomenclature[var==i, keys], "mean", nomenclature[var==j, keys], "average_seq", sep="_"))
    }  
  }  



  for (i in c("TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO")) {
    for (j in c("ESP2_COD_FAO", "SPP_COD_FAO", "FAMILY_COD_FAO", "ORDER_COD_FAO", "ISSCAAP_COD_FAO","STOCK_ORGP", "ENGIN_COD")) {
      quantity= quant_values(SACROIS, "NAVS_COD_YEAR", i, constant=ifelse(i=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID", averaged = T, scale = "SEQ_ID", averaged2 = T, scale2=j, SD2=T);
      data_vessel=merge(data_vessel, quantity, all=T);
      setnames(data_vessel, "V1", paste("val", nomenclature[var==i, keys], "sd", nomenclature[var==j, keys], "average_seq", sep="_"))
    }  
  }  



  for (i in c("TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO")) {
    for (j in c("ESP2_COD_FAO", "SPP_COD_FAO", "FAMILY_COD_FAO", "ORDER_COD_FAO", "ISSCAAP_COD_FAO","STOCK_ORGP", "ENGIN_COD")) {
      quantity= quant_values(SACROIS, "NAVS_COD_YEAR", i, constant=ifelse(i=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID", averaged = T, scale = "SEQ_ID", averaged2 = T, scale2=j, SD=T, SD2=T);
      data_vessel=merge(data_vessel, quantity, all=T);
      setnames(data_vessel, "V1", paste("sd", nomenclature[var==i, keys], "sd", nomenclature[var==j, keys], "average_seq", sep="_"))
    }  
  }  

























  for (i in c("MAILLAGE", "DATE_SEQ_DAY", "MONTH", "TRIMESTRE")) {
    for (j in c("TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO"))
      quantity= quant_values(SACROIS, "NAVS_COD_YEAR", i, constant=ifelse(i=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID", averaged = T, scale = "SEQ_ID", weighted = j);
      data_vessel=merge(data_vessel, quantity, all=T);
      setnames(data_vessel, "V1", paste("value", nomenclature[var==i, keys], "weighted", nomenclature[var==j, keys], "average_seq", sep="_"))
  }  






  for (i in c("MAILLAGE", "DATE_SEQ_DAY", "MONTH", "TRIMESTRE")) {
    for (j in c("TP_NAVIRE_SACROIS", "QUANT_POIDS_VIF_SACROIS", "MONTANT_EUROS_SACROIS", "PROD_POIDS", "PROD_ECO"))
      quantity= quant_values(SACROIS, "NAVS_COD_YEAR", i, constant=ifelse(i=="TP_NAVIRE_SACROIS", T, F), event="SEQ_ID", averaged = T, scale = "SEQ_ID", SD=T, weighted = j);
      data_vessel=merge(data_vessel, quantity, all=T);
      setnames(data_vessel, "V1", paste("sd", nomenclature[var==i, keys], "weighted", nomenclature[var==j, keys], "average_seq", sep="_"))
  }  







###other variables:




  isallNA=dcast(SACROIS,
            NAVS_COD_YEAR ~ ., 
            fun.aggregate = function(x) all(is.na(x)),
            value.var = "TPS_MER")[,.] 

data_vessel$value_time_efficiency_year=NA_real_

data_vessel[!isallNA, value_time_efficiency_year:=
  dcast(SACROIS[!duplicated(SEQ_ID),][!is.na(TPS_MER),],
      NAVS_COD_YEAR ~ ., 
      fun.aggregate = sumna,
      value.var ="TP_NAVIRE_SACROIS")[,.] / dcast(SACROIS[!duplicated(MAREE_ID),],
                                                  NAVS_COD_YEAR ~ ., 
                                                  fun.aggregate = sumna,
                                                  value.var ="TPS_MER")[,.][!isallNA] ]
#assigns the proportion of time spent fishing during the time at sea (yearly), by excluding the cases where the fishing effort is available but not the time spent at sea 

#warning: may be imprecise in the cases where time spent at sea is available but not the fishing effort, partially or not, to have a more precise estimate: we have to remove all vessels having at least one missing value for fishing effort

# this estimate is also imprecise due to marees overlapping two years: here such marees are divided into two subdivision of fishing effort resulting in an underestimation of efficiency (should be negligible at a year scale)



#some vessels have time efficiency values slightly superior to one (<1.001 in most case, with one exception at 1.16) probably due to precision errors, these values are set to 1:

data_vessel[value_time_efficiency_year>1 & !is.na(value_time_efficiency_year),value_time_efficiency_year:=1]









data_vessel[,value_mean_time_efficiency_marees:=
  as.data.table(
    dcast(SACROIS[!duplicated(SEQ_ID),], 
          MAREE_ID~., 
          fun.aggregate = sumna,
          value.var = "TP_NAVIRE_SACROIS")[,.]/dcast(SACROIS, 
                                                     MAREE_ID~., 
                                                     fun.aggregate = function(x) x[1],
                                                     value.var = "TPS_MER")[,.]) 
            [,mean(V1, na.rm=T),by =
                SACROIS[order(MAREE_ID)][!duplicated(MAREE_ID),NAVS_COD_YEAR] ]
              [order(SACROIS)]
                [,V1] ]
#assigns the average proportion of time spent fishing during the time at sea (basic unit: marees) 
  


data_vessel[value_mean_time_efficiency_marees>1 & !is.na(value_mean_time_efficiency_marees),value_mean_time_efficiency_marees:=1]




data_vessel[,sd_time_efficiency_marees:=
  as.data.table(
    dcast(SACROIS[!duplicated(SEQ_ID),], 
          MAREE_ID~., 
          fun.aggregate = sumna,
          value.var = "TP_NAVIRE_SACROIS")[,.]/dcast(SACROIS, 
                                                     MAREE_ID~., 
                                                     fun.aggregate = function(x) x[1],
                                                     value.var = "TPS_MER")[,.]) 
            [,pop.sd(na.omit(V1)),by = 
                SACROIS[order(MAREE_ID)][!duplicated(MAREE_ID),NAVS_COD_YEAR] ] 
              [order(SACROIS)] 
                [,V1] ]
#assigns the variability (standard deviation) in the proportion of time spent fishing during the time at sea (basic unit: marees) 







 rm(list=c("number_cats", "div_cats","main_cats", "number_cats", "second_cats", "third_cats", "quantity", "isallNA"))
gc()

```




